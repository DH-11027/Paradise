{"ast":null,"code":"import { toNum, fmtDate } from './dataUtils';\n\n// Compute Indicators: OBV, MFI(14), ATR(14), Anchored VWAP\nexport function computeIndicators(rows, anchorIndex) {\n  if (!rows || rows.length === 0) return {\n    data: [],\n    obvMax: 0\n  };\n  const data = rows.map(r => ({\n    ...r\n  }));\n  let obv = 0;\n  let prevClose = null;\n  let prevTp = null;\n  const posMF = Array(data.length).fill(0);\n  const negMF = Array(data.length).fill(0);\n  const trArr = Array(data.length).fill(0);\n  for (let i = 0; i < data.length; i++) {\n    const h = toNum(data[i].high);\n    const l = toNum(data[i].low);\n    const c = toNum(data[i].close);\n    const v = toNum(data[i].volume);\n\n    // OBV\n    if (prevClose !== null) {\n      if (c > prevClose) obv += v;else if (c < prevClose) obv -= v;\n    }\n    data[i].obv = obv;\n\n    // Typical price & money flow (MFI)\n    const tp = (h + l + c) / 3;\n    if (prevTp !== null) {\n      const mf = tp * v;\n      if (tp > prevTp) posMF[i] = mf;else if (tp < prevTp) negMF[i] = mf;\n    }\n    data[i].tp = tp;\n\n    // True Range (for ATR)\n    if (prevClose !== null) {\n      const tr = Math.max(h - l, Math.abs(h - prevClose), Math.abs(l - prevClose));\n      trArr[i] = tr;\n    } else {\n      trArr[i] = h - l;\n    }\n    prevClose = c;\n    prevTp = tp;\n  }\n\n  // Rolling ATR (SMA 14)\n  const period = 14;\n  for (let i = 0; i < data.length; i++) {\n    if (i < period) {\n      data[i].atr14 = null;\n    } else {\n      let sum = 0;\n      for (let k = i - period + 1; k <= i; k++) sum += trArr[k];\n      data[i].atr14 = sum / period;\n    }\n  }\n\n  // Rolling MFI(14)\n  for (let i = 0; i < data.length; i++) {\n    if (i < period) {\n      data[i].mfi14 = null;\n    } else {\n      let pos = 0,\n        neg = 0;\n      for (let k = i - period + 1; k <= i; k++) {\n        pos += posMF[k];\n        neg += negMF[k];\n      }\n      const mr = neg === 0 ? 100 : pos / neg;\n      data[i].mfi14 = 100 - 100 / (1 + mr);\n    }\n  }\n\n  // Anchored VWAP from selected anchorIndex (default = first index)\n  const start = Math.max(0, Math.min(anchorIndex !== null && anchorIndex !== void 0 ? anchorIndex : 0, data.length - 1));\n  let cumPV = 0,\n    cumV = 0;\n  for (let i = 0; i < data.length; i++) {\n    if (i < start) {\n      data[i].avwap = null;\n      continue;\n    }\n    const v = toNum(data[i].volume);\n    const p = data[i].tp;\n    cumPV += p * v;\n    cumV += v;\n    data[i].avwap = cumV ? cumPV / cumV : null;\n  }\n  const obvMax = Math.max(...data.map(d => Math.abs(d.obv || 0)));\n  return {\n    data,\n    obvMax\n  };\n}\n\n// 주식수 단위인지 판단 (값이 너무 작으면 주식수로 간주)\nfunction detectVolumeUnit(flowRows) {\n  if (!flowRows || flowRows.length === 0) return false;\n\n  // 첫 번째 데이터의 값들을 확인\n  const firstRow = flowRows[0];\n  const numericKeys = [\"금융투자\", \"보험\", \"투신\", \"사모\", \"은행\", \"기타금융\", \"연기금\", \"기타법인\", \"개인\", \"외국인\", \"기타외국인\"];\n  const values = numericKeys.map(k => toNum(firstRow[k])).filter(v => v !== 0);\n  if (values.length === 0) return false;\n  const maxAbsValue = Math.max(...values.map(Math.abs));\n\n  // 최대 절대값이 1,000,000 미만이면 주식수 단위로 판단\n  const isVolume = maxAbsValue < 1000000;\n  return isVolume;\n}\nexport function mergeInvestorFlows(priceRows, flowRows) {\n  console.log('mergeInvestorFlows called');\n  console.log('- priceRows:', priceRows === null || priceRows === void 0 ? void 0 : priceRows.length);\n  console.log('- flowRows:', flowRows === null || flowRows === void 0 ? void 0 : flowRows.length);\n  if (!flowRows || flowRows.length === 0) {\n    console.log('No flow rows, returning price rows only');\n    return priceRows;\n  }\n\n  // 주식수 단위인지 판단\n  const isVolumeUnit = detectVolumeUnit(flowRows);\n\n  // 주식수 단위면 가격을 곱해서 금액으로 변환\n  let processedFlowRows = flowRows;\n  if (isVolumeUnit) {\n    processedFlowRows = flowRows.map(fr => {\n      const dateKey = fmtDate(fr.date || fr.Date || fr[\"날짜\"]);\n      const priceRow = priceRows.find(p => fmtDate(p.date || p.Date || p[\"날짜\"]) === dateKey);\n      if (!priceRow || !priceRow.close) return fr;\n      const multiplier = toNum(priceRow.close);\n      const converted = {\n        ...fr\n      };\n\n      // 숫자 필드만 변환\n      const numericKeys = [\"금융투자\", \"보험\", \"투신\", \"사모\", \"은행\", \"기타금융\", \"연기금\", \"기타법인\", \"개인\", \"외국인\", \"기타외국인\", \"기관합계\"];\n      numericKeys.forEach(key => {\n        if (fr[key] !== undefined) {\n          converted[key] = toNum(fr[key]) * multiplier;\n        }\n      });\n      return converted;\n    });\n  }\n  const byDate = new Map(processedFlowRows.map(r => [fmtDate(r.date || r.Date || r[\"날짜\"]), r]));\n\n  // Prepare cumulative map for detailed categories\n  const cats = [\"금융투자\", \"보험\", \"투신\", \"사모\", \"은행\", \"기타금융\", \"연기금\", \"기타법인\", \"개인\", \"외국인\", \"기타외국인\", \"기관합계\", \"외국인합계\"];\n  const cumMap = Object.fromEntries(cats.map(k => [k, 0]));\n  let cumF = 0,\n    cumI = 0,\n    cumP = 0;\n  return priceRows.map(p => {\n    var _fr$foreign, _fr$institution;\n    const key = fmtDate(p.date || p.Date || p[\"날짜\"]);\n    const fr = byDate.get(key) || {};\n\n    // Compose details\n    const details = {\n      금융투자: toNum(fr[\"금융투자\"]) || 0,\n      보험: toNum(fr[\"보험\"]) || 0,\n      투신: toNum(fr[\"투신\"]) || 0,\n      사모: toNum(fr[\"사모\"]) || 0,\n      은행: toNum(fr[\"은행\"]) || 0,\n      기타금융: toNum(fr[\"기타금융\"]) || 0,\n      연기금: toNum(fr[\"연기금\"]) || 0,\n      기타법인: toNum(fr[\"기타법인\"]) || 0,\n      개인: toNum(fr[\"개인\"]) || 0,\n      외국인: toNum(fr[\"외국인\"]) || 0,\n      기타외국인: toNum(fr[\"기타외국인\"]) || 0,\n      기관합계: toNum(fr[\"기관합계\"]) || 0\n    };\n    if (!details.기관합계) {\n      details.기관합계 = [\"금융투자\", \"보험\", \"투신\", \"사모\", \"은행\", \"기타금융\", \"연기금\", \"기타법인\"].reduce((s, k) => s + toNum(details[k]), 0);\n    }\n    details[\"외국인합계\"] = details.외국인 + details.기타외국인;\n\n    // For backward-compatibility (existing charts): foreign/institution totals\n    const f = toNum((_fr$foreign = fr.foreign) !== null && _fr$foreign !== void 0 ? _fr$foreign : details[\"외국인합계\"]) || 0;\n    const i = toNum((_fr$institution = fr.institution) !== null && _fr$institution !== void 0 ? _fr$institution : details[\"기관합계\"]) || 0;\n    const person = details.개인 || 0;\n    cumF += f;\n    cumI += i;\n    cumP += person;\n    cats.forEach(k => cumMap[k] += toNum(details[k] || 0));\n    return {\n      ...p,\n      foreign: f,\n      inst: i,\n      person,\n      cumForeign: cumF,\n      cumInst: cumI,\n      cumPerson: cumP,\n      _flows: details,\n      _cum: {\n        ...cumMap\n      }\n    };\n  });\n}","map":{"version":3,"names":["toNum","fmtDate","computeIndicators","rows","anchorIndex","length","data","obvMax","map","r","obv","prevClose","prevTp","posMF","Array","fill","negMF","trArr","i","h","high","l","low","c","close","v","volume","tp","mf","tr","Math","max","abs","period","atr14","sum","k","mfi14","pos","neg","mr","start","min","cumPV","cumV","avwap","p","d","detectVolumeUnit","flowRows","firstRow","numericKeys","values","filter","maxAbsValue","isVolume","mergeInvestorFlows","priceRows","console","log","isVolumeUnit","processedFlowRows","fr","dateKey","date","Date","priceRow","find","multiplier","converted","forEach","key","undefined","byDate","Map","cats","cumMap","Object","fromEntries","cumF","cumI","cumP","_fr$foreign","_fr$institution","get","details","금융투자","보험","투신","사모","은행","기타금융","연기금","기타법인","개인","외국인","기타외국인","기관합계","reduce","s","f","foreign","institution","person","inst","cumForeign","cumInst","cumPerson","_flows","_cum"],"sources":["C:/Users/kloud/OneDrive/Desktop/Paradise/src/utils/indicatorUtils.js"],"sourcesContent":["import { toNum, fmtDate } from './dataUtils';\n\n// Compute Indicators: OBV, MFI(14), ATR(14), Anchored VWAP\nexport function computeIndicators(rows, anchorIndex) {\n  if (!rows || rows.length === 0) return { data: [], obvMax: 0 };\n  const data = rows.map((r) => ({ ...r }));\n  let obv = 0;\n  let prevClose = null;\n  let prevTp = null;\n  const posMF = Array(data.length).fill(0);\n  const negMF = Array(data.length).fill(0);\n  const trArr = Array(data.length).fill(0);\n\n  for (let i = 0; i < data.length; i++) {\n    const h = toNum(data[i].high);\n    const l = toNum(data[i].low);\n    const c = toNum(data[i].close);\n    const v = toNum(data[i].volume);\n\n    // OBV\n    if (prevClose !== null) {\n      if (c > prevClose) obv += v;\n      else if (c < prevClose) obv -= v;\n    }\n    data[i].obv = obv;\n\n    // Typical price & money flow (MFI)\n    const tp = (h + l + c) / 3;\n    if (prevTp !== null) {\n      const mf = tp * v;\n      if (tp > prevTp) posMF[i] = mf; else if (tp < prevTp) negMF[i] = mf;\n    }\n    data[i].tp = tp;\n\n    // True Range (for ATR)\n    if (prevClose !== null) {\n      const tr = Math.max(h - l, Math.abs(h - prevClose), Math.abs(l - prevClose));\n      trArr[i] = tr;\n    } else {\n      trArr[i] = h - l;\n    }\n\n    prevClose = c;\n    prevTp = tp;\n  }\n\n  // Rolling ATR (SMA 14)\n  const period = 14;\n  for (let i = 0; i < data.length; i++) {\n    if (i < period) {\n      data[i].atr14 = null;\n    } else {\n      let sum = 0;\n      for (let k = i - period + 1; k <= i; k++) sum += trArr[k];\n      data[i].atr14 = sum / period;\n    }\n  }\n\n  // Rolling MFI(14)\n  for (let i = 0; i < data.length; i++) {\n    if (i < period) {\n      data[i].mfi14 = null;\n    } else {\n      let pos = 0, neg = 0;\n      for (let k = i - period + 1; k <= i; k++) { pos += posMF[k]; neg += negMF[k]; }\n      const mr = neg === 0 ? 100 : pos / neg;\n      data[i].mfi14 = 100 - 100 / (1 + mr);\n    }\n  }\n\n  // Anchored VWAP from selected anchorIndex (default = first index)\n  const start = Math.max(0, Math.min(anchorIndex ?? 0, data.length - 1));\n  let cumPV = 0, cumV = 0;\n  for (let i = 0; i < data.length; i++) {\n    if (i < start) { data[i].avwap = null; continue; }\n    const v = toNum(data[i].volume);\n    const p = data[i].tp;\n    cumPV += p * v;\n    cumV += v;\n    data[i].avwap = cumV ? cumPV / cumV : null;\n  }\n\n  const obvMax = Math.max(...data.map((d) => Math.abs(d.obv || 0)));\n  return { data, obvMax };\n}\n\n// 주식수 단위인지 판단 (값이 너무 작으면 주식수로 간주)\nfunction detectVolumeUnit(flowRows) {\n  if (!flowRows || flowRows.length === 0) return false;\n  \n  // 첫 번째 데이터의 값들을 확인\n  const firstRow = flowRows[0];\n  const numericKeys = [\"금융투자\", \"보험\", \"투신\", \"사모\", \"은행\", \"기타금융\", \"연기금\", \"기타법인\", \"개인\", \"외국인\", \"기타외국인\"];\n  const values = numericKeys.map(k => toNum(firstRow[k])).filter(v => v !== 0);\n  \n  if (values.length === 0) return false;\n  \n  const maxAbsValue = Math.max(...values.map(Math.abs));\n  \n  // 최대 절대값이 1,000,000 미만이면 주식수 단위로 판단\n  const isVolume = maxAbsValue < 1000000;\n  return isVolume;\n}\n\nexport function mergeInvestorFlows(priceRows, flowRows) {\n  console.log('mergeInvestorFlows called');\n  console.log('- priceRows:', priceRows?.length);\n  console.log('- flowRows:', flowRows?.length);\n  \n  if (!flowRows || flowRows.length === 0) {\n    console.log('No flow rows, returning price rows only');\n    return priceRows;\n  }\n  \n  // 주식수 단위인지 판단\n  const isVolumeUnit = detectVolumeUnit(flowRows);\n  \n  // 주식수 단위면 가격을 곱해서 금액으로 변환\n  let processedFlowRows = flowRows;\n  if (isVolumeUnit) {\n    processedFlowRows = flowRows.map(fr => {\n      const dateKey = fmtDate(fr.date || fr.Date || fr[\"날짜\"]);\n      const priceRow = priceRows.find(p => fmtDate(p.date || p.Date || p[\"날짜\"]) === dateKey);\n      \n      if (!priceRow || !priceRow.close) return fr;\n      \n      const multiplier = toNum(priceRow.close);\n      const converted = { ...fr };\n      \n      // 숫자 필드만 변환\n      const numericKeys = [\"금융투자\", \"보험\", \"투신\", \"사모\", \"은행\", \"기타금융\", \"연기금\", \"기타법인\", \"개인\", \"외국인\", \"기타외국인\", \"기관합계\"];\n      numericKeys.forEach(key => {\n        if (fr[key] !== undefined) {\n          converted[key] = toNum(fr[key]) * multiplier;\n        }\n      });\n      \n      return converted;\n    });\n  }\n  \n  const byDate = new Map(processedFlowRows.map((r) => [fmtDate(r.date || r.Date || r[\"날짜\"]), r]));\n\n  // Prepare cumulative map for detailed categories\n  const cats = [\n    \"금융투자\",\"보험\",\"투신\",\"사모\",\"은행\",\"기타금융\",\"연기금\",\"기타법인\",\"개인\",\"외국인\",\"기타외국인\",\"기관합계\",\"외국인합계\"\n  ];\n  const cumMap = Object.fromEntries(cats.map((k) => [k, 0]));\n\n  let cumF = 0, cumI = 0, cumP = 0;\n\n  return priceRows.map((p) => {\n    const key = fmtDate(p.date || p.Date || p[\"날짜\"]);\n    const fr = byDate.get(key) || {};\n\n    // Compose details\n    const details = {\n      금융투자: toNum(fr[\"금융투자\"]) || 0,\n      보험: toNum(fr[\"보험\"]) || 0,\n      투신: toNum(fr[\"투신\"]) || 0,\n      사모: toNum(fr[\"사모\"]) || 0,\n      은행: toNum(fr[\"은행\"]) || 0,\n      기타금융: toNum(fr[\"기타금융\"]) || 0,\n      연기금: toNum(fr[\"연기금\"]) || 0,\n      기타법인: toNum(fr[\"기타법인\"]) || 0,\n      개인: toNum(fr[\"개인\"]) || 0,\n      외국인: toNum(fr[\"외국인\"]) || 0,\n      기타외국인: toNum(fr[\"기타외국인\"]) || 0,\n      기관합계: toNum(fr[\"기관합계\"]) || 0,\n    };\n    if (!details.기관합계) {\n      details.기관합계 = [\"금융투자\",\"보험\",\"투신\",\"사모\",\"은행\",\"기타금융\",\"연기금\",\"기타법인\"].reduce((s,k)=>s+toNum(details[k]),0);\n    }\n    details[\"외국인합계\"] = details.외국인 + details.기타외국인;\n\n    // For backward-compatibility (existing charts): foreign/institution totals\n    const f = toNum(fr.foreign ?? details[\"외국인합계\"]) || 0;\n    const i = toNum(fr.institution ?? details[\"기관합계\"]) || 0;\n    const person = details.개인 || 0;\n\n    cumF += f; cumI += i; cumP += person;\n    cats.forEach((k) => (cumMap[k] += toNum(details[k] || 0)));\n\n    return {\n      ...p,\n      foreign: f,\n      inst: i,\n      person,\n      cumForeign: cumF,\n      cumInst: cumI,\n      cumPerson: cumP,\n      _flows: details,\n      _cum: { ...cumMap },\n    };\n  });\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}