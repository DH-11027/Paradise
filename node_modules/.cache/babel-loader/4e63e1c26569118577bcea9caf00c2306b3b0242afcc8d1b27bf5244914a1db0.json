{"ast":null,"code":"// 수급 데이터 처리 전용 모듈\n// 날짜 매칭 문제를 완전히 해결\n\nimport { toNum } from './dataUtils';\n\n// 날짜를 YYYY-MM-DD 형식으로 정규화\nexport function normalizeDate(dateStr) {\n  if (!dateStr) return '';\n  const str = String(dateStr).trim();\n\n  // ISO 형식에서 날짜 부분만 추출\n  if (str.includes('T')) {\n    return str.split('T')[0];\n  }\n\n  // YYYY/MM/DD를 YYYY-MM-DD로 변환\n  if (str.includes('/')) {\n    const parts = str.split('/');\n    if (parts.length === 3) {\n      return `${parts[0]}-${parts[1].padStart(2, '0')}-${parts[2].padStart(2, '0')}`;\n    }\n  }\n\n  // YYYY-M-D를 YYYY-MM-DD로 변환\n  if (str.includes('-')) {\n    const parts = str.split('-');\n    if (parts.length === 3) {\n      return `${parts[0]}-${parts[1].padStart(2, '0')}-${parts[2].padStart(2, '0')}`;\n    }\n  }\n  return str;\n}\n\n// CSV 텍스트를 파싱하여 수급 데이터 반환\nexport function parseFlowCSV(csvText) {\n  if (!csvText) return [];\n\n  // BOM 제거\n  let cleanText = csvText;\n  cleanText = cleanText.replace(/^\\uFEFF/, '');\n  cleanText = cleanText.replace(/^\\xEF\\xBB\\xBF/, '');\n  cleanText = cleanText.replace(/^﻿/, '');\n  const lines = cleanText.trim().split(/\\r?\\n/);\n  if (lines.length < 2) return [];\n\n  // 헤더 파싱\n  const headers = lines[0].split(',').map(h => h.trim());\n\n  // 데이터 파싱\n  const data = [];\n  for (let i = 1; i < lines.length; i++) {\n    const values = lines[i].split(',');\n    const row = {};\n    headers.forEach((header, idx) => {\n      var _values$idx;\n      row[header] = ((_values$idx = values[idx]) === null || _values$idx === void 0 ? void 0 : _values$idx.trim()) || '';\n    });\n    data.push(row);\n  }\n  return data;\n}\n\n// 수급 데이터를 정규화\nexport function normalizeFlowData(flowRows) {\n  if (!flowRows || flowRows.length === 0) return [];\n  return flowRows.map((row, idx) => {\n    // 날짜 찾기\n    const dateValue = row['날짜'] || row['date'] || row['Date'] || Object.values(row)[0];\n    const normalized = {\n      date: normalizeDate(dateValue),\n      금융투자: toNum(row['금융투자'] || 0),\n      보험: toNum(row['보험'] || 0),\n      투신: toNum(row['투신'] || 0),\n      사모: toNum(row['사모'] || 0),\n      은행: toNum(row['은행'] || 0),\n      기타금융: toNum(row['기타금융'] || 0),\n      연기금: toNum(row['연기금'] || 0),\n      기타법인: toNum(row['기타법인'] || 0),\n      개인: toNum(row['개인'] || 0),\n      외국인: toNum(row['외국인'] || 0),\n      기타외국인: toNum(row['기타외국인'] || 0),\n      기관합계: toNum(row['기관합계'] || 0)\n    };\n    if (idx === 0) {\n      console.log('First normalized flow row:', {\n        date: normalized.date,\n        외국인: normalized.외국인,\n        기타외국인: normalized.기타외국인,\n        개인: normalized.개인,\n        기관합계: normalized.기관합계\n      });\n    }\n\n    // 기관합계가 없으면 계산\n    if (!normalized.기관합계) {\n      normalized.기관합계 = normalized.금융투자 + normalized.보험 + normalized.투신 + normalized.사모 + normalized.은행 + normalized.기타금융 + normalized.연기금 + normalized.기타법인;\n    }\n\n    // 외국인합계 계산\n    normalized.외국인합계 = normalized.외국인 + normalized.기타외국인;\n    return normalized;\n  });\n}\n\n// 가격 데이터와 수급 데이터 병합\nexport function mergeFlowWithPrice(priceRows, flowRows) {\n  if (!priceRows || priceRows.length === 0) return priceRows;\n  if (!flowRows || flowRows.length === 0) return priceRows;\n\n  // 수급 데이터를 날짜별 Map으로 변환\n  const flowMap = new Map();\n  flowRows.forEach(row => {\n    const date = normalizeDate(row.date);\n    if (date) {\n      flowMap.set(date, row);\n    }\n  });\n  console.log('Flow map created with', flowMap.size, 'entries');\n  console.log('Sample flow dates:', Array.from(flowMap.keys()).slice(0, 5));\n\n  // 누적 계산용 변수\n  const categories = ['금융투자', '보험', '투신', '사모', '은행', '기타금융', '연기금', '기타법인', '개인', '외국인', '기타외국인', '기관합계', '외국인합계'];\n  const cumulative = {};\n  categories.forEach(cat => {\n    cumulative[cat] = 0;\n  });\n  let cumForeign = 0;\n  let cumInst = 0;\n  let cumPerson = 0;\n\n  // 가격 데이터에 수급 데이터 병합\n  return priceRows.map((priceRow, idx) => {\n    const priceDate = normalizeDate(priceRow.date || priceRow.Date);\n    const flowData = flowMap.get(priceDate);\n    if (idx < 5) {\n      console.log(`Merging row ${idx}: price date=${priceDate}, flow found=${!!flowData}`);\n      if (flowData) {\n        console.log('Flow data sample:', {\n          금융투자: flowData.금융투자,\n          개인: flowData.개인,\n          외국인: flowData.외국인,\n          기타외국인: flowData.기타외국인,\n          외국인합계: flowData.외국인합계,\n          기관합계: flowData.기관합계\n        });\n      }\n    }\n\n    // 수급 데이터가 있으면 사용, 없으면 0\n    const flows = flowData || {\n      금융투자: 0,\n      보험: 0,\n      투신: 0,\n      사모: 0,\n      은행: 0,\n      기타금융: 0,\n      연기금: 0,\n      기타법인: 0,\n      개인: 0,\n      외국인: 0,\n      기타외국인: 0,\n      기관합계: 0,\n      외국인합계: 0\n    };\n\n    // 누적 계산\n    categories.forEach(cat => {\n      cumulative[cat] += flows[cat] || 0;\n    });\n    cumForeign += flows.외국인합계 || 0;\n    cumInst += flows.기관합계 || 0;\n    cumPerson += flows.개인 || 0;\n    return {\n      ...priceRow,\n      _flows: {\n        ...flows\n      },\n      _cum: {\n        ...cumulative\n      },\n      cumForeign,\n      cumInst,\n      cumPerson,\n      foreign: flows.외국인합계 || 0,\n      inst: flows.기관합계 || 0,\n      person: flows.개인 || 0\n    };\n  });\n}\n\n// 주식수 단위인지 판단\nexport function isVolumeUnit(flowRows) {\n  if (!flowRows || flowRows.length === 0) return false;\n  const firstRow = flowRows[0];\n  const values = Object.values(firstRow).filter(v => typeof v === 'number' && v !== 0).map(Math.abs);\n  if (values.length === 0) return false;\n  const maxValue = Math.max(...values);\n  return maxValue < 1000000; // 100만 미만이면 주식수로 판단\n}\n\n// 주식수를 금액으로 변환\nexport function convertVolumeToAmount(flowRows, priceRows) {\n  if (!flowRows || flowRows.length === 0) return flowRows;\n  if (!priceRows || priceRows.length === 0) return flowRows;\n\n  // 가격 데이터 Map 생성\n  const priceMap = new Map();\n  priceRows.forEach(row => {\n    const date = normalizeDate(row.date || row.Date);\n    if (date && row.close) {\n      priceMap.set(date, toNum(row.close));\n    }\n  });\n\n  // 수급 데이터 변환\n  return flowRows.map(flowRow => {\n    const date = normalizeDate(flowRow.date);\n    const price = priceMap.get(date);\n    if (!price) return flowRow;\n    const converted = {\n      ...flowRow\n    };\n    const numericKeys = ['금융투자', '보험', '투신', '사모', '은행', '기타금융', '연기금', '기타법인', '개인', '외국인', '기타외국인', '기관합계'];\n    numericKeys.forEach(key => {\n      if (typeof converted[key] === 'number') {\n        converted[key] = converted[key] * price;\n      }\n    });\n    return converted;\n  });\n}\n\n// 통합 처리 함수\nexport function processFlowData(flowCSV, priceRows) {\n  console.log('processFlowData called');\n  if (!flowCSV || !priceRows) {\n    console.log('Missing flow CSV or price rows');\n    return priceRows || [];\n  }\n\n  // 1. CSV 파싱\n  const rawFlowData = parseFlowCSV(flowCSV);\n  console.log('Parsed', rawFlowData.length, 'flow rows');\n  if (rawFlowData.length === 0) {\n    console.log('No flow data parsed');\n    return priceRows;\n  }\n\n  // 2. 데이터 정규화\n  let flowData = normalizeFlowData(rawFlowData);\n  console.log('Normalized', flowData.length, 'flow rows');\n\n  // 3. 주식수 단위 확인 및 변환\n  if (isVolumeUnit(flowData)) {\n    console.log('Volume unit detected, converting to amount');\n    flowData = convertVolumeToAmount(flowData, priceRows);\n  }\n\n  // 4. 가격 데이터와 병합\n  const merged = mergeFlowWithPrice(priceRows, flowData);\n  console.log('Merged data created');\n  return merged;\n}\nexport default {\n  normalizeDate,\n  parseFlowCSV,\n  normalizeFlowData,\n  mergeFlowWithPrice,\n  isVolumeUnit,\n  convertVolumeToAmount,\n  processFlowData\n};","map":{"version":3,"names":["toNum","normalizeDate","dateStr","str","String","trim","includes","split","parts","length","padStart","parseFlowCSV","csvText","cleanText","replace","lines","headers","map","h","data","i","values","row","forEach","header","idx","_values$idx","push","normalizeFlowData","flowRows","dateValue","Object","normalized","date","금융투자","보험","투신","사모","은행","기타금융","연기금","기타법인","개인","외국인","기타외국인","기관합계","console","log","외국인합계","mergeFlowWithPrice","priceRows","flowMap","Map","set","size","Array","from","keys","slice","categories","cumulative","cat","cumForeign","cumInst","cumPerson","priceRow","priceDate","Date","flowData","get","flows","_flows","_cum","foreign","inst","person","isVolumeUnit","firstRow","filter","v","Math","abs","maxValue","max","convertVolumeToAmount","priceMap","close","flowRow","price","converted","numericKeys","key","processFlowData","flowCSV","rawFlowData","merged"],"sources":["C:/Users/kloud/OneDrive/Desktop/Paradise/src/utils/flowDataProcessor.js"],"sourcesContent":["// 수급 데이터 처리 전용 모듈\n// 날짜 매칭 문제를 완전히 해결\n\nimport { toNum } from './dataUtils';\n\n// 날짜를 YYYY-MM-DD 형식으로 정규화\nexport function normalizeDate(dateStr) {\n  if (!dateStr) return '';\n  \n  const str = String(dateStr).trim();\n  \n  // ISO 형식에서 날짜 부분만 추출\n  if (str.includes('T')) {\n    return str.split('T')[0];\n  }\n  \n  // YYYY/MM/DD를 YYYY-MM-DD로 변환\n  if (str.includes('/')) {\n    const parts = str.split('/');\n    if (parts.length === 3) {\n      return `${parts[0]}-${parts[1].padStart(2, '0')}-${parts[2].padStart(2, '0')}`;\n    }\n  }\n  \n  // YYYY-M-D를 YYYY-MM-DD로 변환\n  if (str.includes('-')) {\n    const parts = str.split('-');\n    if (parts.length === 3) {\n      return `${parts[0]}-${parts[1].padStart(2, '0')}-${parts[2].padStart(2, '0')}`;\n    }\n  }\n  \n  return str;\n}\n\n// CSV 텍스트를 파싱하여 수급 데이터 반환\nexport function parseFlowCSV(csvText) {\n  if (!csvText) return [];\n  \n  // BOM 제거\n  let cleanText = csvText;\n  cleanText = cleanText.replace(/^\\uFEFF/, '');\n  cleanText = cleanText.replace(/^\\xEF\\xBB\\xBF/, '');\n  cleanText = cleanText.replace(/^﻿/, '');\n  \n  const lines = cleanText.trim().split(/\\r?\\n/);\n  if (lines.length < 2) return [];\n  \n  // 헤더 파싱\n  const headers = lines[0].split(',').map(h => h.trim());\n  \n  // 데이터 파싱\n  const data = [];\n  for (let i = 1; i < lines.length; i++) {\n    const values = lines[i].split(',');\n    const row = {};\n    \n    headers.forEach((header, idx) => {\n      row[header] = values[idx]?.trim() || '';\n    });\n    \n    data.push(row);\n  }\n  \n  return data;\n}\n\n// 수급 데이터를 정규화\nexport function normalizeFlowData(flowRows) {\n  if (!flowRows || flowRows.length === 0) return [];\n  \n  return flowRows.map((row, idx) => {\n    // 날짜 찾기\n    const dateValue = row['날짜'] || row['date'] || row['Date'] || Object.values(row)[0];\n    \n    const normalized = {\n      date: normalizeDate(dateValue),\n      금융투자: toNum(row['금융투자'] || 0),\n      보험: toNum(row['보험'] || 0),\n      투신: toNum(row['투신'] || 0),\n      사모: toNum(row['사모'] || 0),\n      은행: toNum(row['은행'] || 0),\n      기타금융: toNum(row['기타금융'] || 0),\n      연기금: toNum(row['연기금'] || 0),\n      기타법인: toNum(row['기타법인'] || 0),\n      개인: toNum(row['개인'] || 0),\n      외국인: toNum(row['외국인'] || 0),\n      기타외국인: toNum(row['기타외국인'] || 0),\n      기관합계: toNum(row['기관합계'] || 0)\n    };\n    \n    if (idx === 0) {\n      console.log('First normalized flow row:', {\n        date: normalized.date,\n        외국인: normalized.외국인,\n        기타외국인: normalized.기타외국인,\n        개인: normalized.개인,\n        기관합계: normalized.기관합계\n      });\n    }\n    \n    // 기관합계가 없으면 계산\n    if (!normalized.기관합계) {\n      normalized.기관합계 = \n        normalized.금융투자 + normalized.보험 + normalized.투신 + \n        normalized.사모 + normalized.은행 + normalized.기타금융 + \n        normalized.연기금 + normalized.기타법인;\n    }\n    \n    // 외국인합계 계산\n    normalized.외국인합계 = normalized.외국인 + normalized.기타외국인;\n    \n    return normalized;\n  });\n}\n\n// 가격 데이터와 수급 데이터 병합\nexport function mergeFlowWithPrice(priceRows, flowRows) {\n  if (!priceRows || priceRows.length === 0) return priceRows;\n  if (!flowRows || flowRows.length === 0) return priceRows;\n  \n  // 수급 데이터를 날짜별 Map으로 변환\n  const flowMap = new Map();\n  flowRows.forEach(row => {\n    const date = normalizeDate(row.date);\n    if (date) {\n      flowMap.set(date, row);\n    }\n  });\n  \n  console.log('Flow map created with', flowMap.size, 'entries');\n  console.log('Sample flow dates:', Array.from(flowMap.keys()).slice(0, 5));\n  \n  // 누적 계산용 변수\n  const categories = ['금융투자', '보험', '투신', '사모', '은행', '기타금융', '연기금', '기타법인', '개인', '외국인', '기타외국인', '기관합계', '외국인합계'];\n  const cumulative = {};\n  categories.forEach(cat => { cumulative[cat] = 0; });\n  \n  let cumForeign = 0;\n  let cumInst = 0;\n  let cumPerson = 0;\n  \n  // 가격 데이터에 수급 데이터 병합\n  return priceRows.map((priceRow, idx) => {\n    const priceDate = normalizeDate(priceRow.date || priceRow.Date);\n    const flowData = flowMap.get(priceDate);\n    \n    if (idx < 5) {\n      console.log(`Merging row ${idx}: price date=${priceDate}, flow found=${!!flowData}`);\n      if (flowData) {\n        console.log('Flow data sample:', { \n          금융투자: flowData.금융투자, \n          개인: flowData.개인,\n          외국인: flowData.외국인,\n          기타외국인: flowData.기타외국인,\n          외국인합계: flowData.외국인합계,\n          기관합계: flowData.기관합계\n        });\n      }\n    }\n    \n    // 수급 데이터가 있으면 사용, 없으면 0\n    const flows = flowData || {\n      금융투자: 0, 보험: 0, 투신: 0, 사모: 0, 은행: 0,\n      기타금융: 0, 연기금: 0, 기타법인: 0, 개인: 0,\n      외국인: 0, 기타외국인: 0, 기관합계: 0, 외국인합계: 0\n    };\n    \n    // 누적 계산\n    categories.forEach(cat => {\n      cumulative[cat] += flows[cat] || 0;\n    });\n    \n    cumForeign += flows.외국인합계 || 0;\n    cumInst += flows.기관합계 || 0;\n    cumPerson += flows.개인 || 0;\n    \n    return {\n      ...priceRow,\n      _flows: { ...flows },\n      _cum: { ...cumulative },\n      cumForeign,\n      cumInst,\n      cumPerson,\n      foreign: flows.외국인합계 || 0,\n      inst: flows.기관합계 || 0,\n      person: flows.개인 || 0\n    };\n  });\n}\n\n// 주식수 단위인지 판단\nexport function isVolumeUnit(flowRows) {\n  if (!flowRows || flowRows.length === 0) return false;\n  \n  const firstRow = flowRows[0];\n  const values = Object.values(firstRow)\n    .filter(v => typeof v === 'number' && v !== 0)\n    .map(Math.abs);\n  \n  if (values.length === 0) return false;\n  \n  const maxValue = Math.max(...values);\n  return maxValue < 1000000; // 100만 미만이면 주식수로 판단\n}\n\n// 주식수를 금액으로 변환\nexport function convertVolumeToAmount(flowRows, priceRows) {\n  if (!flowRows || flowRows.length === 0) return flowRows;\n  if (!priceRows || priceRows.length === 0) return flowRows;\n  \n  // 가격 데이터 Map 생성\n  const priceMap = new Map();\n  priceRows.forEach(row => {\n    const date = normalizeDate(row.date || row.Date);\n    if (date && row.close) {\n      priceMap.set(date, toNum(row.close));\n    }\n  });\n  \n  // 수급 데이터 변환\n  return flowRows.map(flowRow => {\n    const date = normalizeDate(flowRow.date);\n    const price = priceMap.get(date);\n    \n    if (!price) return flowRow;\n    \n    const converted = { ...flowRow };\n    const numericKeys = ['금융투자', '보험', '투신', '사모', '은행', '기타금융', '연기금', '기타법인', '개인', '외국인', '기타외국인', '기관합계'];\n    \n    numericKeys.forEach(key => {\n      if (typeof converted[key] === 'number') {\n        converted[key] = converted[key] * price;\n      }\n    });\n    \n    return converted;\n  });\n}\n\n// 통합 처리 함수\nexport function processFlowData(flowCSV, priceRows) {\n  console.log('processFlowData called');\n  \n  if (!flowCSV || !priceRows) {\n    console.log('Missing flow CSV or price rows');\n    return priceRows || [];\n  }\n  \n  // 1. CSV 파싱\n  const rawFlowData = parseFlowCSV(flowCSV);\n  console.log('Parsed', rawFlowData.length, 'flow rows');\n  \n  if (rawFlowData.length === 0) {\n    console.log('No flow data parsed');\n    return priceRows;\n  }\n  \n  // 2. 데이터 정규화\n  let flowData = normalizeFlowData(rawFlowData);\n  console.log('Normalized', flowData.length, 'flow rows');\n  \n  // 3. 주식수 단위 확인 및 변환\n  if (isVolumeUnit(flowData)) {\n    console.log('Volume unit detected, converting to amount');\n    flowData = convertVolumeToAmount(flowData, priceRows);\n  }\n  \n  // 4. 가격 데이터와 병합\n  const merged = mergeFlowWithPrice(priceRows, flowData);\n  console.log('Merged data created');\n  \n  return merged;\n}\n\nexport default {\n  normalizeDate,\n  parseFlowCSV,\n  normalizeFlowData,\n  mergeFlowWithPrice,\n  isVolumeUnit,\n  convertVolumeToAmount,\n  processFlowData\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}