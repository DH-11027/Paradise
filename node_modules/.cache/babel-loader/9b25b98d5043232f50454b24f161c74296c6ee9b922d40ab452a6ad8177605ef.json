{"ast":null,"code":"import { parseCSV, toNum } from './dataUtils';\n\n// =============================\n// Investor mapping & parsing (KRX style, Korean headers)\n// =============================\nexport const INVESTOR_KEYS = [\"금융투자\", \"보험\", \"투신\", \"사모\", \"은행\", \"기타금융\", \"연기금\", \"기타법인\", \"개인\", \"외국인\", \"기타외국인\", \"기관합계\"];\nexport function normalizeInvestorRow(r) {\n  console.log('Normalizing row:', Object.keys(r).slice(0, 5));\n  const get = (k, alts = []) => {\n    const cand = [k, ...alts];\n    for (const key of cand) {\n      if (r[key] !== undefined) {\n        const value = toNum(r[key]);\n        if (value !== 0 && k === \"금융투자\") {\n          console.log(`Found 금융투자: ${value}`);\n        }\n        return value;\n      }\n    }\n    return 0;\n  };\n  // 날짜 찾기 - 다양한 형식 지원\n  let dateValue = r.date || r.Date || r[\"날짜\"] || r[\"﻿날짜\"] || Object.values(r)[0];\n  console.log('Date value found:', dateValue);\n  const out = {\n    date: dateValue,\n    금융투자: get(\"금융투자\", [\"Securities\", \"FinancialInvestment\"]),\n    보험: get(\"보험\", [\"Insurance\"]),\n    투신: get(\"투신\", [\"InvestmentTrust\"]),\n    사모: get(\"사모\", [\"PrivateEquity\", \"사모펀드\"]),\n    은행: get(\"은행\", [\"Bank\"]),\n    기타금융: get(\"기타금융\", [\"OtherFinance\"]),\n    연기금: get(\"연기금\", [\"Pension\"]),\n    기타법인: get(\"기타법인\", [\"OtherCorporation\"]),\n    개인: get(\"개인\", [\"Individual\"]),\n    외국인: get(\"외국인\", [\"Foreigner\", \"Foreign\"]),\n    기타외국인: get(\"기타외국인\", [\"OtherForeigner\"]),\n    기관합계: get(\"기관합계\", [\"기관\", \"InstitutionTotal\"])\n  };\n  console.log('Normalized row output:', {\n    date: out.date,\n    금융투자: out.금융투자,\n    개인: out.개인\n  });\n  // If 기관합계 not provided or zero, compute from parts (excluding 개인/외국인 계열)\n  if (!out.기관합계) {\n    const parts = [\"금융투자\", \"보험\", \"투신\", \"사모\", \"은행\", \"기타금융\", \"연기금\", \"기타법인\"];\n    out.기관합계 = parts.reduce((s, k) => s + toNum(out[k]), 0);\n  }\n  return out;\n}\nexport function parseInvestorFlowCSV(text) {\n  console.log('parseInvestorFlowCSV called, text length:', text === null || text === void 0 ? void 0 : text.length);\n  console.log('First 200 chars of text:', text === null || text === void 0 ? void 0 : text.substring(0, 200));\n\n  // 1) 일반 CSV/TSV 시도\n  let raw = parseCSV(text);\n  console.log('Raw CSV parsed, rows:', raw.length);\n  if (raw.length > 0) {\n    console.log('First raw row:', raw[0]);\n  }\n  let parsed = raw.map(normalizeInvestorRow).filter(r => r.date).sort((a, b) => new Date(a.date) - new Date(b.date));\n  console.log('After normalize and filter, rows:', parsed.length);\n  if (parsed.length > 0) {\n    console.log('First parsed row:', parsed[0]);\n  }\n\n  // 2) 실패하면: 헤더에 탭/콤마가 없고 공백이 있으면 공백 기준 파싱\n  if (parsed.length === 0) {\n    const lines = text.trim().split(/\\r?\\n/);\n    const head = lines[0] || \"\";\n    const looksWS = !head.includes(\",\") && !head.includes(\"\\t\") && /\\s+/.test(head);\n    if (looksWS) {\n      // 공백으로 구분된 데이터를 직접 파싱\n      const headers = head.trim().split(/\\s+/);\n      const rows = lines.slice(1).map(line => {\n        const values = line.trim().split(/\\s+/);\n        const row = {};\n        headers.forEach((h, i) => {\n          row[h] = values[i] || \"\";\n        });\n        return row;\n      });\n      parsed = rows.map(normalizeInvestorRow).filter(r => r.date).sort((a, b) => new Date(a.date) - new Date(b.date));\n    }\n  }\n  return parsed;\n}","map":{"version":3,"names":["parseCSV","toNum","INVESTOR_KEYS","normalizeInvestorRow","r","console","log","Object","keys","slice","get","k","alts","cand","key","undefined","value","dateValue","date","Date","values","out","금융투자","보험","투신","사모","은행","기타금융","연기금","기타법인","개인","외국인","기타외국인","기관합계","parts","reduce","s","parseInvestorFlowCSV","text","length","substring","raw","parsed","map","filter","sort","a","b","lines","trim","split","head","looksWS","includes","test","headers","rows","line","row","forEach","h","i"],"sources":["C:/Users/kloud/OneDrive/Desktop/Paradise/src/utils/investorUtils.js"],"sourcesContent":["import { parseCSV, toNum } from './dataUtils';\n\n// =============================\n// Investor mapping & parsing (KRX style, Korean headers)\n// =============================\nexport const INVESTOR_KEYS = [\n  \"금융투자\",\"보험\",\"투신\",\"사모\",\"은행\",\"기타금융\",\"연기금\",\"기타법인\",\"개인\",\"외국인\",\"기타외국인\",\"기관합계\"\n];\n\nexport function normalizeInvestorRow(r) {\n  console.log('Normalizing row:', Object.keys(r).slice(0, 5));\n  \n  const get = (k, alts=[]) => {\n    const cand = [k, ...alts];\n    for (const key of cand) {\n      if (r[key] !== undefined) {\n        const value = toNum(r[key]);\n        if (value !== 0 && k === \"금융투자\") {\n          console.log(`Found 금융투자: ${value}`);\n        }\n        return value;\n      }\n    }\n    return 0;\n  };\n  // 날짜 찾기 - 다양한 형식 지원\n  let dateValue = r.date || r.Date || r[\"날짜\"] || r[\"﻿날짜\"] || Object.values(r)[0];\n  console.log('Date value found:', dateValue);\n  \n  const out = {\n    date: dateValue,\n    금융투자: get(\"금융투자\", [\"Securities\",\"FinancialInvestment\"]),\n    보험: get(\"보험\", [\"Insurance\"]),\n    투신: get(\"투신\", [\"InvestmentTrust\"]),\n    사모: get(\"사모\", [\"PrivateEquity\",\"사모펀드\"]),\n    은행: get(\"은행\", [\"Bank\"]),\n    기타금융: get(\"기타금융\", [\"OtherFinance\"]),\n    연기금: get(\"연기금\", [\"Pension\"]),\n    기타법인: get(\"기타법인\", [\"OtherCorporation\"]),\n    개인: get(\"개인\", [\"Individual\"]),\n    외국인: get(\"외국인\", [\"Foreigner\",\"Foreign\"]),\n    기타외국인: get(\"기타외국인\", [\"OtherForeigner\"]),\n    기관합계: get(\"기관합계\", [\"기관\", \"InstitutionTotal\"]),\n  };\n  \n  console.log('Normalized row output:', { date: out.date, 금융투자: out.금융투자, 개인: out.개인 });\n  // If 기관합계 not provided or zero, compute from parts (excluding 개인/외국인 계열)\n  if (!out.기관합계) {\n    const parts = [\"금융투자\",\"보험\",\"투신\",\"사모\",\"은행\",\"기타금융\",\"연기금\",\"기타법인\"];\n    out.기관합계 = parts.reduce((s,k)=>s+toNum(out[k]),0);\n  }\n  return out;\n}\n\nexport function parseInvestorFlowCSV(text) {\n  console.log('parseInvestorFlowCSV called, text length:', text?.length);\n  console.log('First 200 chars of text:', text?.substring(0, 200));\n  \n  // 1) 일반 CSV/TSV 시도\n  let raw = parseCSV(text);\n  console.log('Raw CSV parsed, rows:', raw.length);\n  if (raw.length > 0) {\n    console.log('First raw row:', raw[0]);\n  }\n  \n  let parsed = raw\n    .map(normalizeInvestorRow)\n    .filter((r) => r.date)\n    .sort((a, b) => new Date(a.date) - new Date(b.date));\n  \n  console.log('After normalize and filter, rows:', parsed.length);\n  if (parsed.length > 0) {\n    console.log('First parsed row:', parsed[0]);\n  }\n\n  // 2) 실패하면: 헤더에 탭/콤마가 없고 공백이 있으면 공백 기준 파싱\n  if (parsed.length === 0) {\n    const lines = text.trim().split(/\\r?\\n/);\n    const head = lines[0] || \"\";\n    const looksWS = !head.includes(\",\") && !head.includes(\"\\t\") && /\\s+/.test(head);\n    if (looksWS) {\n      // 공백으로 구분된 데이터를 직접 파싱\n      const headers = head.trim().split(/\\s+/);\n      const rows = lines.slice(1).map(line => {\n        const values = line.trim().split(/\\s+/);\n        const row = {};\n        headers.forEach((h, i) => {\n          row[h] = values[i] || \"\";\n        });\n        return row;\n      });\n      parsed = rows\n        .map(normalizeInvestorRow)\n        .filter((r) => r.date)\n        .sort((a, b) => new Date(a.date) - new Date(b.date));\n    }\n  }\n  return parsed;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}