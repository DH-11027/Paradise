{"ast":null,"code":"// 수급 데이터 처리 전용 모듈\n// 날짜 매칭 문제를 완전히 해결\n\nimport { toNum } from './dataUtils';\n\n// 날짜를 YYYY-MM-DD 형식으로 정규화\nexport function normalizeDate(dateStr) {\n  if (!dateStr) return '';\n  const str = String(dateStr).trim();\n\n  // ISO 형식에서 날짜 부분만 추출\n  if (str.includes('T')) {\n    return str.split('T')[0];\n  }\n\n  // YYYY/MM/DD를 YYYY-MM-DD로 변환\n  if (str.includes('/')) {\n    const parts = str.split('/');\n    if (parts.length === 3) {\n      return `${parts[0]}-${parts[1].padStart(2, '0')}-${parts[2].padStart(2, '0')}`;\n    }\n  }\n\n  // YYYY-M-D를 YYYY-MM-DD로 변환\n  if (str.includes('-')) {\n    const parts = str.split('-');\n    if (parts.length === 3) {\n      return `${parts[0]}-${parts[1].padStart(2, '0')}-${parts[2].padStart(2, '0')}`;\n    }\n  }\n  return str;\n}\n\n// CSV 텍스트를 파싱하여 수급 데이터 반환\nexport function parseFlowCSV(csvText) {\n  if (!csvText) return [];\n\n  // BOM 제거 - 여러 방법으로 시도\n  let cleanText = csvText;\n  cleanText = cleanText.replace(/^\\uFEFF/, '');\n  cleanText = cleanText.replace(/^\\xEF\\xBB\\xBF/, '');\n  cleanText = cleanText.replace(/^﻿/, '');\n\n  // BOM이 첫 문자인 경우 제거\n  if (cleanText.charCodeAt(0) === 0xFEFF || cleanText.charCodeAt(0) === 65279) {\n    cleanText = cleanText.substring(1);\n  }\n  const lines = cleanText.trim().split(/\\r?\\n/);\n  if (lines.length < 2) return [];\n\n  // 헤더 파싱 - BOM 한번 더 제거\n  const firstLine = lines[0].replace(/^\\uFEFF/, '').replace(/^﻿/, '');\n  const headers = firstLine.split(',').map(h => {\n    // 각 헤더에서도 BOM과 공백 제거\n    let cleaned = h.trim();\n    cleaned = cleaned.replace(/^\\uFEFF/, '');\n    cleaned = cleaned.replace(/^﻿/, '');\n    return cleaned;\n  });\n  console.log('Parsed CSV headers:', headers);\n\n  // 데이터 파싱\n  const data = [];\n  for (let i = 1; i < lines.length; i++) {\n    const values = lines[i].split(',');\n    const row = {};\n    headers.forEach((header, idx) => {\n      var _values$idx;\n      row[header] = ((_values$idx = values[idx]) === null || _values$idx === void 0 ? void 0 : _values$idx.trim()) || '';\n    });\n    data.push(row);\n  }\n  console.log('Parsed', data.length, 'rows from CSV');\n  if (data.length > 0) {\n    console.log('First row keys:', Object.keys(data[0]));\n    console.log('First row 외국인:', data[0]['외국인']);\n  }\n  return data;\n}\n\n// 수급 데이터를 정규화\nexport function normalizeFlowData(flowRows) {\n  if (!flowRows || flowRows.length === 0) return [];\n  return flowRows.map((row, idx) => {\n    // 날짜 찾기\n    const dateValue = row['날짜'] || row['date'] || row['Date'] || Object.values(row)[0];\n    const normalized = {\n      date: normalizeDate(dateValue),\n      금융투자: toNum(row['금융투자'] || 0),\n      보험: toNum(row['보험'] || 0),\n      투신: toNum(row['투신'] || 0),\n      사모: toNum(row['사모'] || 0),\n      은행: toNum(row['은행'] || 0),\n      기타금융: toNum(row['기타금융'] || 0),\n      연기금: toNum(row['연기금'] || 0),\n      기타법인: toNum(row['기타법인'] || 0),\n      개인: toNum(row['개인'] || 0),\n      외국인: toNum(row['외국인'] || 0),\n      기타외국인: toNum(row['기타외국인'] || 0),\n      기관합계: toNum(row['기관합계'] || 0)\n    };\n    if (idx === 0) {\n      console.log('First normalized flow row:', {\n        date: normalized.date,\n        외국인: normalized.외국인,\n        기타외국인: normalized.기타외국인,\n        개인: normalized.개인,\n        기관합계: normalized.기관합계\n      });\n    }\n\n    // 기관합계가 없으면 계산\n    if (!normalized.기관합계) {\n      normalized.기관합계 = normalized.금융투자 + normalized.보험 + normalized.투신 + normalized.사모 + normalized.은행 + normalized.기타금융 + normalized.연기금 + normalized.기타법인;\n    }\n\n    // 외국인합계 계산\n    normalized.외국인합계 = normalized.외국인 + normalized.기타외국인;\n    return normalized;\n  });\n}\n\n// 가격 데이터와 수급 데이터 병합\nexport function mergeFlowWithPrice(priceRows, flowRows) {\n  if (!priceRows || priceRows.length === 0) return priceRows;\n  if (!flowRows || flowRows.length === 0) return priceRows;\n\n  // 수급 데이터를 날짜별 Map으로 변환\n  const flowMap = new Map();\n  flowRows.forEach(row => {\n    const date = normalizeDate(row.date);\n    if (date) {\n      flowMap.set(date, row);\n    }\n  });\n  console.log('Flow map created with', flowMap.size, 'entries');\n  console.log('Sample flow dates:', Array.from(flowMap.keys()).slice(0, 5));\n\n  // 누적 계산용 변수\n  const categories = ['금융투자', '보험', '투신', '사모', '은행', '기타금융', '연기금', '기타법인', '개인', '외국인', '기타외국인', '기관합계', '외국인합계'];\n  const cumulative = {};\n  categories.forEach(cat => {\n    cumulative[cat] = 0;\n  });\n  let cumForeign = 0;\n  let cumInst = 0;\n  let cumPerson = 0;\n\n  // 가격 데이터에 수급 데이터 병합\n  return priceRows.map((priceRow, idx) => {\n    const priceDate = normalizeDate(priceRow.date || priceRow.Date);\n    const flowData = flowMap.get(priceDate);\n    if (idx < 5) {\n      console.log(`Merging row ${idx}: price date=${priceDate}, flow found=${!!flowData}`);\n      if (flowData) {\n        console.log('Flow data sample:', {\n          금융투자: flowData.금융투자,\n          개인: flowData.개인,\n          외국인: flowData.외국인,\n          기타외국인: flowData.기타외국인,\n          외국인합계: flowData.외국인합계,\n          기관합계: flowData.기관합계\n        });\n      }\n    }\n\n    // 수급 데이터가 있으면 사용, 없으면 0\n    const flows = flowData || {\n      금융투자: 0,\n      보험: 0,\n      투신: 0,\n      사모: 0,\n      은행: 0,\n      기타금융: 0,\n      연기금: 0,\n      기타법인: 0,\n      개인: 0,\n      외국인: 0,\n      기타외국인: 0,\n      기관합계: 0,\n      외국인합계: 0\n    };\n\n    // 누적 계산\n    categories.forEach(cat => {\n      cumulative[cat] += flows[cat] || 0;\n    });\n    cumForeign += flows.외국인합계 || 0;\n    cumInst += flows.기관합계 || 0;\n    cumPerson += flows.개인 || 0;\n    return {\n      ...priceRow,\n      _flows: {\n        ...flows\n      },\n      _cum: {\n        ...cumulative\n      },\n      cumForeign,\n      cumInst,\n      cumPerson,\n      foreign: flows.외국인합계 || 0,\n      inst: flows.기관합계 || 0,\n      person: flows.개인 || 0\n    };\n  });\n}\n\n// 주식수 단위인지 판단\nexport function isVolumeUnit(flowRows) {\n  if (!flowRows || flowRows.length === 0) return false;\n  const firstRow = flowRows[0];\n  const values = Object.values(firstRow).filter(v => typeof v === 'number' && v !== 0).map(Math.abs);\n  if (values.length === 0) return false;\n  const maxValue = Math.max(...values);\n  return maxValue < 1000000; // 100만 미만이면 주식수로 판단\n}\n\n// 주식수를 금액으로 변환\nexport function convertVolumeToAmount(flowRows, priceRows) {\n  if (!flowRows || flowRows.length === 0) return flowRows;\n  if (!priceRows || priceRows.length === 0) return flowRows;\n\n  // 가격 데이터 Map 생성\n  const priceMap = new Map();\n  priceRows.forEach(row => {\n    const date = normalizeDate(row.date || row.Date);\n    if (date && row.close) {\n      priceMap.set(date, toNum(row.close));\n    }\n  });\n\n  // 수급 데이터 변환\n  return flowRows.map(flowRow => {\n    const date = normalizeDate(flowRow.date);\n    const price = priceMap.get(date);\n    if (!price) return flowRow;\n    const converted = {\n      ...flowRow\n    };\n    const numericKeys = ['금융투자', '보험', '투신', '사모', '은행', '기타금융', '연기금', '기타법인', '개인', '외국인', '기타외국인', '기관합계'];\n    numericKeys.forEach(key => {\n      if (typeof converted[key] === 'number') {\n        converted[key] = converted[key] * price;\n      }\n    });\n    return converted;\n  });\n}\n\n// 통합 처리 함수\nexport function processFlowData(flowCSV, priceRows) {\n  console.log('processFlowData called');\n  if (!flowCSV || !priceRows) {\n    console.log('Missing flow CSV or price rows');\n    return priceRows || [];\n  }\n\n  // 1. CSV 파싱\n  const rawFlowData = parseFlowCSV(flowCSV);\n  console.log('Parsed', rawFlowData.length, 'flow rows');\n  if (rawFlowData.length === 0) {\n    console.log('No flow data parsed');\n    return priceRows;\n  }\n\n  // 2. 데이터 정규화\n  let flowData = normalizeFlowData(rawFlowData);\n  console.log('Normalized', flowData.length, 'flow rows');\n\n  // 3. 주식수 단위 확인 및 변환\n  if (isVolumeUnit(flowData)) {\n    console.log('Volume unit detected, converting to amount');\n    flowData = convertVolumeToAmount(flowData, priceRows);\n  }\n\n  // 4. 가격 데이터와 병합\n  const merged = mergeFlowWithPrice(priceRows, flowData);\n  console.log('Merged data created');\n  return merged;\n}\nexport default {\n  normalizeDate,\n  parseFlowCSV,\n  normalizeFlowData,\n  mergeFlowWithPrice,\n  isVolumeUnit,\n  convertVolumeToAmount,\n  processFlowData\n};","map":{"version":3,"names":["toNum","normalizeDate","dateStr","str","String","trim","includes","split","parts","length","padStart","parseFlowCSV","csvText","cleanText","replace","charCodeAt","substring","lines","firstLine","headers","map","h","cleaned","console","log","data","i","values","row","forEach","header","idx","_values$idx","push","Object","keys","normalizeFlowData","flowRows","dateValue","normalized","date","금융투자","보험","투신","사모","은행","기타금융","연기금","기타법인","개인","외국인","기타외국인","기관합계","외국인합계","mergeFlowWithPrice","priceRows","flowMap","Map","set","size","Array","from","slice","categories","cumulative","cat","cumForeign","cumInst","cumPerson","priceRow","priceDate","Date","flowData","get","flows","_flows","_cum","foreign","inst","person","isVolumeUnit","firstRow","filter","v","Math","abs","maxValue","max","convertVolumeToAmount","priceMap","close","flowRow","price","converted","numericKeys","key","processFlowData","flowCSV","rawFlowData","merged"],"sources":["C:/Users/kloud/OneDrive/Desktop/Paradise/src/utils/flowDataProcessor.js"],"sourcesContent":["// 수급 데이터 처리 전용 모듈\n// 날짜 매칭 문제를 완전히 해결\n\nimport { toNum } from './dataUtils';\n\n// 날짜를 YYYY-MM-DD 형식으로 정규화\nexport function normalizeDate(dateStr) {\n  if (!dateStr) return '';\n  \n  const str = String(dateStr).trim();\n  \n  // ISO 형식에서 날짜 부분만 추출\n  if (str.includes('T')) {\n    return str.split('T')[0];\n  }\n  \n  // YYYY/MM/DD를 YYYY-MM-DD로 변환\n  if (str.includes('/')) {\n    const parts = str.split('/');\n    if (parts.length === 3) {\n      return `${parts[0]}-${parts[1].padStart(2, '0')}-${parts[2].padStart(2, '0')}`;\n    }\n  }\n  \n  // YYYY-M-D를 YYYY-MM-DD로 변환\n  if (str.includes('-')) {\n    const parts = str.split('-');\n    if (parts.length === 3) {\n      return `${parts[0]}-${parts[1].padStart(2, '0')}-${parts[2].padStart(2, '0')}`;\n    }\n  }\n  \n  return str;\n}\n\n// CSV 텍스트를 파싱하여 수급 데이터 반환\nexport function parseFlowCSV(csvText) {\n  if (!csvText) return [];\n  \n  // BOM 제거 - 여러 방법으로 시도\n  let cleanText = csvText;\n  cleanText = cleanText.replace(/^\\uFEFF/, '');\n  cleanText = cleanText.replace(/^\\xEF\\xBB\\xBF/, '');\n  cleanText = cleanText.replace(/^﻿/, '');\n  \n  // BOM이 첫 문자인 경우 제거\n  if (cleanText.charCodeAt(0) === 0xFEFF || cleanText.charCodeAt(0) === 65279) {\n    cleanText = cleanText.substring(1);\n  }\n  \n  const lines = cleanText.trim().split(/\\r?\\n/);\n  if (lines.length < 2) return [];\n  \n  // 헤더 파싱 - BOM 한번 더 제거\n  const firstLine = lines[0].replace(/^\\uFEFF/, '').replace(/^﻿/, '');\n  const headers = firstLine.split(',').map(h => {\n    // 각 헤더에서도 BOM과 공백 제거\n    let cleaned = h.trim();\n    cleaned = cleaned.replace(/^\\uFEFF/, '');\n    cleaned = cleaned.replace(/^﻿/, '');\n    return cleaned;\n  });\n  \n  console.log('Parsed CSV headers:', headers);\n  \n  // 데이터 파싱\n  const data = [];\n  for (let i = 1; i < lines.length; i++) {\n    const values = lines[i].split(',');\n    const row = {};\n    \n    headers.forEach((header, idx) => {\n      row[header] = values[idx]?.trim() || '';\n    });\n    \n    data.push(row);\n  }\n  \n  console.log('Parsed', data.length, 'rows from CSV');\n  if (data.length > 0) {\n    console.log('First row keys:', Object.keys(data[0]));\n    console.log('First row 외국인:', data[0]['외국인']);\n  }\n  \n  return data;\n}\n\n// 수급 데이터를 정규화\nexport function normalizeFlowData(flowRows) {\n  if (!flowRows || flowRows.length === 0) return [];\n  \n  return flowRows.map((row, idx) => {\n    // 날짜 찾기\n    const dateValue = row['날짜'] || row['date'] || row['Date'] || Object.values(row)[0];\n    \n    const normalized = {\n      date: normalizeDate(dateValue),\n      금융투자: toNum(row['금융투자'] || 0),\n      보험: toNum(row['보험'] || 0),\n      투신: toNum(row['투신'] || 0),\n      사모: toNum(row['사모'] || 0),\n      은행: toNum(row['은행'] || 0),\n      기타금융: toNum(row['기타금융'] || 0),\n      연기금: toNum(row['연기금'] || 0),\n      기타법인: toNum(row['기타법인'] || 0),\n      개인: toNum(row['개인'] || 0),\n      외국인: toNum(row['외국인'] || 0),\n      기타외국인: toNum(row['기타외국인'] || 0),\n      기관합계: toNum(row['기관합계'] || 0)\n    };\n    \n    if (idx === 0) {\n      console.log('First normalized flow row:', {\n        date: normalized.date,\n        외국인: normalized.외국인,\n        기타외국인: normalized.기타외국인,\n        개인: normalized.개인,\n        기관합계: normalized.기관합계\n      });\n    }\n    \n    // 기관합계가 없으면 계산\n    if (!normalized.기관합계) {\n      normalized.기관합계 = \n        normalized.금융투자 + normalized.보험 + normalized.투신 + \n        normalized.사모 + normalized.은행 + normalized.기타금융 + \n        normalized.연기금 + normalized.기타법인;\n    }\n    \n    // 외국인합계 계산\n    normalized.외국인합계 = normalized.외국인 + normalized.기타외국인;\n    \n    return normalized;\n  });\n}\n\n// 가격 데이터와 수급 데이터 병합\nexport function mergeFlowWithPrice(priceRows, flowRows) {\n  if (!priceRows || priceRows.length === 0) return priceRows;\n  if (!flowRows || flowRows.length === 0) return priceRows;\n  \n  // 수급 데이터를 날짜별 Map으로 변환\n  const flowMap = new Map();\n  flowRows.forEach(row => {\n    const date = normalizeDate(row.date);\n    if (date) {\n      flowMap.set(date, row);\n    }\n  });\n  \n  console.log('Flow map created with', flowMap.size, 'entries');\n  console.log('Sample flow dates:', Array.from(flowMap.keys()).slice(0, 5));\n  \n  // 누적 계산용 변수\n  const categories = ['금융투자', '보험', '투신', '사모', '은행', '기타금융', '연기금', '기타법인', '개인', '외국인', '기타외국인', '기관합계', '외국인합계'];\n  const cumulative = {};\n  categories.forEach(cat => { cumulative[cat] = 0; });\n  \n  let cumForeign = 0;\n  let cumInst = 0;\n  let cumPerson = 0;\n  \n  // 가격 데이터에 수급 데이터 병합\n  return priceRows.map((priceRow, idx) => {\n    const priceDate = normalizeDate(priceRow.date || priceRow.Date);\n    const flowData = flowMap.get(priceDate);\n    \n    if (idx < 5) {\n      console.log(`Merging row ${idx}: price date=${priceDate}, flow found=${!!flowData}`);\n      if (flowData) {\n        console.log('Flow data sample:', { \n          금융투자: flowData.금융투자, \n          개인: flowData.개인,\n          외국인: flowData.외국인,\n          기타외국인: flowData.기타외국인,\n          외국인합계: flowData.외국인합계,\n          기관합계: flowData.기관합계\n        });\n      }\n    }\n    \n    // 수급 데이터가 있으면 사용, 없으면 0\n    const flows = flowData || {\n      금융투자: 0, 보험: 0, 투신: 0, 사모: 0, 은행: 0,\n      기타금융: 0, 연기금: 0, 기타법인: 0, 개인: 0,\n      외국인: 0, 기타외국인: 0, 기관합계: 0, 외국인합계: 0\n    };\n    \n    // 누적 계산\n    categories.forEach(cat => {\n      cumulative[cat] += flows[cat] || 0;\n    });\n    \n    cumForeign += flows.외국인합계 || 0;\n    cumInst += flows.기관합계 || 0;\n    cumPerson += flows.개인 || 0;\n    \n    return {\n      ...priceRow,\n      _flows: { ...flows },\n      _cum: { ...cumulative },\n      cumForeign,\n      cumInst,\n      cumPerson,\n      foreign: flows.외국인합계 || 0,\n      inst: flows.기관합계 || 0,\n      person: flows.개인 || 0\n    };\n  });\n}\n\n// 주식수 단위인지 판단\nexport function isVolumeUnit(flowRows) {\n  if (!flowRows || flowRows.length === 0) return false;\n  \n  const firstRow = flowRows[0];\n  const values = Object.values(firstRow)\n    .filter(v => typeof v === 'number' && v !== 0)\n    .map(Math.abs);\n  \n  if (values.length === 0) return false;\n  \n  const maxValue = Math.max(...values);\n  return maxValue < 1000000; // 100만 미만이면 주식수로 판단\n}\n\n// 주식수를 금액으로 변환\nexport function convertVolumeToAmount(flowRows, priceRows) {\n  if (!flowRows || flowRows.length === 0) return flowRows;\n  if (!priceRows || priceRows.length === 0) return flowRows;\n  \n  // 가격 데이터 Map 생성\n  const priceMap = new Map();\n  priceRows.forEach(row => {\n    const date = normalizeDate(row.date || row.Date);\n    if (date && row.close) {\n      priceMap.set(date, toNum(row.close));\n    }\n  });\n  \n  // 수급 데이터 변환\n  return flowRows.map(flowRow => {\n    const date = normalizeDate(flowRow.date);\n    const price = priceMap.get(date);\n    \n    if (!price) return flowRow;\n    \n    const converted = { ...flowRow };\n    const numericKeys = ['금융투자', '보험', '투신', '사모', '은행', '기타금융', '연기금', '기타법인', '개인', '외국인', '기타외국인', '기관합계'];\n    \n    numericKeys.forEach(key => {\n      if (typeof converted[key] === 'number') {\n        converted[key] = converted[key] * price;\n      }\n    });\n    \n    return converted;\n  });\n}\n\n// 통합 처리 함수\nexport function processFlowData(flowCSV, priceRows) {\n  console.log('processFlowData called');\n  \n  if (!flowCSV || !priceRows) {\n    console.log('Missing flow CSV or price rows');\n    return priceRows || [];\n  }\n  \n  // 1. CSV 파싱\n  const rawFlowData = parseFlowCSV(flowCSV);\n  console.log('Parsed', rawFlowData.length, 'flow rows');\n  \n  if (rawFlowData.length === 0) {\n    console.log('No flow data parsed');\n    return priceRows;\n  }\n  \n  // 2. 데이터 정규화\n  let flowData = normalizeFlowData(rawFlowData);\n  console.log('Normalized', flowData.length, 'flow rows');\n  \n  // 3. 주식수 단위 확인 및 변환\n  if (isVolumeUnit(flowData)) {\n    console.log('Volume unit detected, converting to amount');\n    flowData = convertVolumeToAmount(flowData, priceRows);\n  }\n  \n  // 4. 가격 데이터와 병합\n  const merged = mergeFlowWithPrice(priceRows, flowData);\n  console.log('Merged data created');\n  \n  return merged;\n}\n\nexport default {\n  normalizeDate,\n  parseFlowCSV,\n  normalizeFlowData,\n  mergeFlowWithPrice,\n  isVolumeUnit,\n  convertVolumeToAmount,\n  processFlowData\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}