{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useMemo } from \"react\";\nimport { parseCSV, toNum } from \"../utils/dataUtils\";\nimport { parseInvestorFlowCSV } from \"../utils/investorUtils\";\nimport { computeIndicators, mergeInvestorFlows } from \"../utils/indicatorUtils\";\nimport { sampleOHLCV, sampleFlowBreakdown } from \"../constants/sampleData\";\nexport function useDataProcessing(priceCSV, flowCSV, useSample, anchorIndex) {\n  _s();\n  const priceRows = useMemo(() => {\n    if (!priceCSV) return [];\n    const raw = parseCSV(priceCSV);\n    // Flexible header mapping (supports merged single-CSV that already includes flow columns)\n    return raw.map(r => {\n      var _ref, _r$open, _ref2, _r$high, _ref3, _r$low, _ref4, _r$close, _ref5, _r$volume, _ref6, _ref7, _ref8, _r$foreign, _ref9, _ref0, _ref1, _r$institution;\n      return {\n        date: r.date || r.Date || r[\"날짜\"],\n        open: toNum((_ref = (_r$open = r.open) !== null && _r$open !== void 0 ? _r$open : r.Open) !== null && _ref !== void 0 ? _ref : r[\"시가\"]),\n        high: toNum((_ref2 = (_r$high = r.high) !== null && _r$high !== void 0 ? _r$high : r.High) !== null && _ref2 !== void 0 ? _ref2 : r[\"고가\"]),\n        low: toNum((_ref3 = (_r$low = r.low) !== null && _r$low !== void 0 ? _r$low : r.Low) !== null && _ref3 !== void 0 ? _ref3 : r[\"저가\"]),\n        close: toNum((_ref4 = (_r$close = r.close) !== null && _r$close !== void 0 ? _r$close : r.Close) !== null && _ref4 !== void 0 ? _ref4 : r[\"종가\"]),\n        volume: toNum((_ref5 = (_r$volume = r.volume) !== null && _r$volume !== void 0 ? _r$volume : r.Volume) !== null && _ref5 !== void 0 ? _ref5 : r[\"거래량\"]),\n        // if merged CSV, keep possible flow fields too (will be ignored here)\n        foreign: toNum((_ref6 = (_ref7 = (_ref8 = (_r$foreign = r.foreign) !== null && _r$foreign !== void 0 ? _r$foreign : r.Foreign) !== null && _ref8 !== void 0 ? _ref8 : r[\"외국인\"]) !== null && _ref7 !== void 0 ? _ref7 : r[\"ForeignNetBuy\"]) !== null && _ref6 !== void 0 ? _ref6 : r[\"ForeignNetBuy_MKRW\"]),\n        institution: toNum((_ref9 = (_ref0 = (_ref1 = (_r$institution = r.institution) !== null && _r$institution !== void 0 ? _r$institution : r.Institution) !== null && _ref1 !== void 0 ? _ref1 : r[\"기관\"]) !== null && _ref0 !== void 0 ? _ref0 : r[\"InstitutionNetBuy\"]) !== null && _ref9 !== void 0 ? _ref9 : r[\"InstitutionNetBuy_MKRW\"])\n      };\n    }).filter(r => r.date && r.close).sort((a, b) => new Date(a.date) - new Date(b.date));\n  }, [priceCSV]);\n  const flowRows = useMemo(() => {\n    if (!flowCSV) return [];\n\n    // 1) Detailed KRX-style CSV\n    const detailed = parseInvestorFlowCSV(flowCSV);\n    if (detailed.length > 0) return detailed;\n\n    // 2) Fallback to simple flow CSV if provided\n    const raw = parseCSV(flowCSV);\n    let parsed = raw.map(r => {\n      var _ref10, _ref11, _ref12, _r$foreign2, _ref13, _ref14, _ref15, _r$institution2;\n      return {\n        date: r.date || r.Date || r[\"날짜\"],\n        foreign: toNum((_ref10 = (_ref11 = (_ref12 = (_r$foreign2 = r.foreign) !== null && _r$foreign2 !== void 0 ? _r$foreign2 : r.Foreign) !== null && _ref12 !== void 0 ? _ref12 : r[\"외국인\"]) !== null && _ref11 !== void 0 ? _ref11 : r[\"ForeignNetBuy\"]) !== null && _ref10 !== void 0 ? _ref10 : r[\"ForeignNetBuy_MKRW\"]),\n        institution: toNum((_ref13 = (_ref14 = (_ref15 = (_r$institution2 = r.institution) !== null && _r$institution2 !== void 0 ? _r$institution2 : r.Institution) !== null && _ref15 !== void 0 ? _ref15 : r[\"기관\"]) !== null && _ref14 !== void 0 ? _ref14 : r[\"InstitutionNetBuy\"]) !== null && _ref13 !== void 0 ? _ref13 : r[\"InstitutionNetBuy_MKRW\"])\n      };\n    }).filter(r => r.date).sort((a, b) => new Date(a.date) - new Date(b.date));\n\n    // 3) If user provided a single merged CSV (only in left textarea), derive from priceRows\n    if (parsed.length === 0 && priceRows.length > 0) {\n      const derived = priceRows.filter(p => p.date && (p.foreign !== undefined || p.institution !== undefined)).map(p => ({\n        date: p.date,\n        foreign: toNum(p.foreign),\n        institution: toNum(p.institution)\n      }));\n      if (derived.length > 0) parsed = derived;\n    }\n    return parsed;\n  }, [flowCSV, useSample, priceRows]);\n  const merged = useMemo(() => mergeInvestorFlows(priceRows, flowRows), [priceRows, flowRows]);\n  const {\n    data: enriched\n  } = useMemo(() => computeIndicators(merged, anchorIndex), [merged, anchorIndex]);\n  return {\n    priceRows,\n    flowRows,\n    merged,\n    enriched\n  };\n}\n_s(useDataProcessing, \"YkBTlPS4Msu6Y6kGs8qk+K1GEfM=\");","map":{"version":3,"names":["useMemo","parseCSV","toNum","parseInvestorFlowCSV","computeIndicators","mergeInvestorFlows","sampleOHLCV","sampleFlowBreakdown","useDataProcessing","priceCSV","flowCSV","useSample","anchorIndex","_s","priceRows","raw","map","r","_ref","_r$open","_ref2","_r$high","_ref3","_r$low","_ref4","_r$close","_ref5","_r$volume","_ref6","_ref7","_ref8","_r$foreign","_ref9","_ref0","_ref1","_r$institution","date","Date","open","Open","high","High","low","Low","close","Close","volume","Volume","foreign","Foreign","institution","Institution","filter","sort","a","b","flowRows","detailed","length","parsed","_ref10","_ref11","_ref12","_r$foreign2","_ref13","_ref14","_ref15","_r$institution2","derived","p","undefined","merged","data","enriched"],"sources":["C:/Users/kloud/OneDrive/Desktop/Paradise/src/hooks/useDataProcessing.js"],"sourcesContent":["import { useMemo } from \"react\";\nimport { parseCSV, toNum } from \"../utils/dataUtils\";\nimport { parseInvestorFlowCSV } from \"../utils/investorUtils\";\nimport { computeIndicators, mergeInvestorFlows } from \"../utils/indicatorUtils\";\nimport { sampleOHLCV, sampleFlowBreakdown } from \"../constants/sampleData\";\n\nexport function useDataProcessing(priceCSV, flowCSV, useSample, anchorIndex) {\n  const priceRows = useMemo(() => {\n    if (!priceCSV) return [];\n    const raw = parseCSV(priceCSV);\n    // Flexible header mapping (supports merged single-CSV that already includes flow columns)\n    return raw\n      .map((r) => ({\n        date: r.date || r.Date || r[\"날짜\"],\n        open: toNum(r.open ?? r.Open ?? r[\"시가\"]),\n        high: toNum(r.high ?? r.High ?? r[\"고가\"]),\n        low: toNum(r.low ?? r.Low ?? r[\"저가\"]),\n        close: toNum(r.close ?? r.Close ?? r[\"종가\"]),\n        volume: toNum(r.volume ?? r.Volume ?? r[\"거래량\"]),\n        // if merged CSV, keep possible flow fields too (will be ignored here)\n        foreign: toNum(\n          r.foreign ?? r.Foreign ?? r[\"외국인\"] ?? r[\"ForeignNetBuy\"] ?? r[\"ForeignNetBuy_MKRW\"]\n        ),\n        institution: toNum(\n          r.institution ?? r.Institution ?? r[\"기관\"] ?? r[\"InstitutionNetBuy\"] ?? r[\"InstitutionNetBuy_MKRW\"]\n        ),\n      }))\n      .filter((r) => r.date && r.close)\n      .sort((a, b) => new Date(a.date) - new Date(b.date));\n  }, [priceCSV]);\n\n  const flowRows = useMemo(() => {\n    if (!flowCSV) return [];\n\n    // 1) Detailed KRX-style CSV\n    const detailed = parseInvestorFlowCSV(flowCSV);\n    if (detailed.length > 0) return detailed;\n\n    // 2) Fallback to simple flow CSV if provided\n    const raw = parseCSV(flowCSV);\n    let parsed = raw\n      .map((r) => ({\n        date: r.date || r.Date || r[\"날짜\"],\n        foreign: toNum(\n          r.foreign ?? r.Foreign ?? r[\"외국인\"] ?? r[\"ForeignNetBuy\"] ?? r[\"ForeignNetBuy_MKRW\"]\n        ),\n        institution: toNum(\n          r.institution ?? r.Institution ?? r[\"기관\"] ?? r[\"InstitutionNetBuy\"] ?? r[\"InstitutionNetBuy_MKRW\"]\n        ),\n      }))\n      .filter((r) => r.date)\n      .sort((a, b) => new Date(a.date) - new Date(b.date));\n\n    // 3) If user provided a single merged CSV (only in left textarea), derive from priceRows\n    if (parsed.length === 0 && priceRows.length > 0) {\n      const derived = priceRows\n        .filter((p) => p.date && (p.foreign !== undefined || p.institution !== undefined))\n        .map((p) => ({ date: p.date, foreign: toNum(p.foreign), institution: toNum(p.institution) }));\n      if (derived.length > 0) parsed = derived;\n    }\n\n    return parsed;\n  }, [flowCSV, useSample, priceRows]);\n\n  const merged = useMemo(() => mergeInvestorFlows(priceRows, flowRows), [priceRows, flowRows]);\n  const { data: enriched } = useMemo(() => computeIndicators(merged, anchorIndex), [merged, anchorIndex]);\n\n  return { priceRows, flowRows, merged, enriched };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}