{"ast":null,"code":"// 수급 데이터 처리 전용 모듈\n// 날짜 매칭 문제를 완전히 해결\n\nimport { toNum } from './dataUtils';\nimport { debugFlowData } from './debugFlowData';\n\n// 날짜를 YYYY-MM-DD 형식으로 정규화\nexport function normalizeDate(dateStr) {\n  if (!dateStr) return '';\n  const str = String(dateStr).trim();\n\n  // ISO 형식에서 날짜 부분만 추출\n  if (str.includes('T')) {\n    return str.split('T')[0];\n  }\n\n  // YYYY/MM/DD를 YYYY-MM-DD로 변환\n  if (str.includes('/')) {\n    const parts = str.split('/');\n    if (parts.length === 3) {\n      return `${parts[0]}-${parts[1].padStart(2, '0')}-${parts[2].padStart(2, '0')}`;\n    }\n  }\n\n  // YYYY-M-D를 YYYY-MM-DD로 변환\n  if (str.includes('-')) {\n    const parts = str.split('-');\n    if (parts.length === 3) {\n      return `${parts[0]}-${parts[1].padStart(2, '0')}-${parts[2].padStart(2, '0')}`;\n    }\n  }\n  return str;\n}\n\n// CSV 텍스트를 파싱하여 수급 데이터 반환\nexport function parseFlowCSV(csvText) {\n  if (!csvText) return [];\n\n  // BOM 제거 - 매우 철저하게\n  let cleanText = csvText;\n\n  // UTF-8 BOM (EF BB BF)\n  while (cleanText.charCodeAt(0) === 0xEF && cleanText.charCodeAt(1) === 0xBB && cleanText.charCodeAt(2) === 0xBF) {\n    cleanText = cleanText.substring(3);\n  }\n\n  // UTF-16 BOM (FE FF or FF FE)\n  while (cleanText.charCodeAt(0) === 0xFEFF || cleanText.charCodeAt(0) === 0xFFFE || cleanText.charCodeAt(0) === 65279) {\n    cleanText = cleanText.substring(1);\n  }\n\n  // 다른 형태의 BOM 제거\n  cleanText = cleanText.replace(/^\\uFEFF/, '');\n  cleanText = cleanText.replace(/^\\xEF\\xBB\\xBF/, '');\n  cleanText = cleanText.replace(/^﻿/, '');\n  const lines = cleanText.trim().split(/\\r?\\n/);\n  if (lines.length < 2) return [];\n\n  // 헤더 파싱\n  const firstLine = lines[0];\n  const headers = firstLine.split(',').map((h, idx) => {\n    // 각 헤더 정리\n    let cleaned = h.trim();\n\n    // 첫 번째 헤더는 특별히 BOM 제거\n    if (idx === 0) {\n      // 모든 가능한 BOM 제거\n      cleaned = cleaned.replace(/^[\\uFEFF\\xEF\\xBB\\xBF]/, '');\n      cleaned = cleaned.replace(/^﻿/, '');\n      // \"날짜\"만 남기기\n      if (cleaned.includes('날짜')) {\n        cleaned = '날짜';\n      }\n    }\n    return cleaned;\n  });\n  console.log('Clean headers:', headers);\n  console.log('Headers includes 외국인?', headers.includes('외국인'));\n  console.log('Headers includes 기타외국인?', headers.includes('기타외국인'));\n\n  // 데이터 파싱\n  const data = [];\n  for (let i = 1; i < lines.length; i++) {\n    const values = lines[i].split(',');\n    const row = {};\n    headers.forEach((header, idx) => {\n      var _values$idx;\n      row[header] = ((_values$idx = values[idx]) === null || _values$idx === void 0 ? void 0 : _values$idx.trim()) || '';\n    });\n    data.push(row);\n  }\n  console.log('Parsed', data.length, 'rows from CSV');\n  if (data.length > 0) {\n    console.log('First row keys:', Object.keys(data[0]));\n    console.log('First row 외국인:', data[0]['외국인']);\n    console.log('First row 기타외국인:', data[0]['기타외국인']);\n    console.log('First row 개인:', data[0]['개인']);\n  }\n  return data;\n}\n\n// 수급 데이터를 정규화\nexport function normalizeFlowData(flowRows) {\n  if (!flowRows || flowRows.length === 0) return [];\n  return flowRows.map((row, idx) => {\n    // 날짜 찾기\n    const dateValue = row['날짜'] || row['date'] || row['Date'] || Object.values(row)[0];\n    const normalized = {\n      date: normalizeDate(dateValue),\n      금융투자: toNum(row['금융투자'] || 0),\n      보험: toNum(row['보험'] || 0),\n      투신: toNum(row['투신'] || 0),\n      사모: toNum(row['사모'] || 0),\n      은행: toNum(row['은행'] || 0),\n      기타금융: toNum(row['기타금융'] || 0),\n      연기금: toNum(row['연기금'] || 0),\n      기타법인: toNum(row['기타법인'] || 0),\n      개인: toNum(row['개인'] || 0),\n      외국인: toNum(row['외국인'] || 0),\n      기타외국인: toNum(row['기타외국인'] || 0),\n      기관합계: toNum(row['기관합계'] || 0)\n    };\n    if (idx === 0) {\n      console.log('First normalized flow row:', {\n        date: normalized.date,\n        외국인: normalized.외국인,\n        기타외국인: normalized.기타외국인,\n        개인: normalized.개인,\n        기관합계: normalized.기관합계\n      });\n    }\n\n    // 기관합계가 없으면 계산\n    if (!normalized.기관합계) {\n      normalized.기관합계 = normalized.금융투자 + normalized.보험 + normalized.투신 + normalized.사모 + normalized.은행 + normalized.기타금융 + normalized.연기금 + normalized.기타법인;\n    }\n\n    // 외국인합계 계산\n    normalized.외국인합계 = normalized.외국인 + normalized.기타외국인;\n    return normalized;\n  });\n}\n\n// 가격 데이터와 수급 데이터 병합\nexport function mergeFlowWithPrice(priceRows, flowRows) {\n  if (!priceRows || priceRows.length === 0) return priceRows;\n  if (!flowRows || flowRows.length === 0) return priceRows;\n\n  // 수급 데이터를 날짜별 Map으로 변환\n  const flowMap = new Map();\n  flowRows.forEach(row => {\n    const date = normalizeDate(row.date);\n    if (date) {\n      flowMap.set(date, row);\n    }\n  });\n  console.log('Flow map created with', flowMap.size, 'entries');\n  console.log('Sample flow dates:', Array.from(flowMap.keys()).slice(0, 5));\n\n  // 누적 계산용 변수\n  const categories = ['금융투자', '보험', '투신', '사모', '은행', '기타금융', '연기금', '기타법인', '개인', '외국인', '기타외국인', '기관합계', '외국인합계'];\n  const cumulative = {};\n  categories.forEach(cat => {\n    cumulative[cat] = 0;\n  });\n  let cumForeign = 0;\n  let cumInst = 0;\n  let cumPerson = 0;\n\n  // 가격 데이터에 수급 데이터 병합\n  return priceRows.map((priceRow, idx) => {\n    const priceDate = normalizeDate(priceRow.date || priceRow.Date);\n    const flowData = flowMap.get(priceDate);\n    if (idx < 5) {\n      console.log(`Merging row ${idx}: price date=${priceDate}, flow found=${!!flowData}`);\n      if (flowData) {\n        console.log('Flow data sample:', {\n          금융투자: flowData.금융투자,\n          개인: flowData.개인,\n          외국인: flowData.외국인,\n          기타외국인: flowData.기타외국인,\n          외국인합계: flowData.외국인합계,\n          기관합계: flowData.기관합계\n        });\n      }\n    }\n\n    // 수급 데이터가 있으면 사용, 없으면 0\n    const flows = flowData || {\n      금융투자: 0,\n      보험: 0,\n      투신: 0,\n      사모: 0,\n      은행: 0,\n      기타금융: 0,\n      연기금: 0,\n      기타법인: 0,\n      개인: 0,\n      외국인: 0,\n      기타외국인: 0,\n      기관합계: 0,\n      외국인합계: 0\n    };\n\n    // 누적 계산\n    categories.forEach(cat => {\n      cumulative[cat] += flows[cat] || 0;\n    });\n    cumForeign += flows.외국인합계 || 0;\n    cumInst += flows.기관합계 || 0;\n    cumPerson += flows.개인 || 0;\n    return {\n      ...priceRow,\n      _flows: {\n        ...flows\n      },\n      _cum: {\n        ...cumulative\n      },\n      cumForeign,\n      cumInst,\n      cumPerson,\n      foreign: flows.외국인합계 || 0,\n      inst: flows.기관합계 || 0,\n      person: flows.개인 || 0\n    };\n  });\n}\n\n// 주식수 단위인지 판단\nexport function isVolumeUnit(flowRows) {\n  if (!flowRows || flowRows.length === 0) return false;\n  const firstRow = flowRows[0];\n  const values = Object.values(firstRow).filter(v => typeof v === 'number' && v !== 0).map(Math.abs);\n  if (values.length === 0) return false;\n  const maxValue = Math.max(...values);\n  return maxValue < 1000000; // 100만 미만이면 주식수로 판단\n}\n\n// 주식수를 금액으로 변환\nexport function convertVolumeToAmount(flowRows, priceRows) {\n  if (!flowRows || flowRows.length === 0) return flowRows;\n  if (!priceRows || priceRows.length === 0) return flowRows;\n\n  // 가격 데이터 Map 생성\n  const priceMap = new Map();\n  priceRows.forEach(row => {\n    const date = normalizeDate(row.date || row.Date);\n    if (date && row.close) {\n      priceMap.set(date, toNum(row.close));\n    }\n  });\n\n  // 수급 데이터 변환\n  return flowRows.map(flowRow => {\n    const date = normalizeDate(flowRow.date);\n    const price = priceMap.get(date);\n    if (!price) return flowRow;\n    const converted = {\n      ...flowRow\n    };\n    const numericKeys = ['금융투자', '보험', '투신', '사모', '은행', '기타금융', '연기금', '기타법인', '개인', '외국인', '기타외국인', '기관합계'];\n    numericKeys.forEach(key => {\n      if (typeof converted[key] === 'number') {\n        converted[key] = converted[key] * price;\n      }\n    });\n    return converted;\n  });\n}\n\n// 통합 처리 함수\nexport function processFlowData(flowCSV, priceRows) {\n  console.log('processFlowData called');\n  if (!flowCSV || !priceRows) {\n    console.log('Missing flow CSV or price rows');\n    return priceRows || [];\n  }\n\n  // 디버깅: 외국인 데이터 확인\n  debugFlowData(flowCSV);\n\n  // 1. CSV 파싱\n  const rawFlowData = parseFlowCSV(flowCSV);\n  console.log('Parsed', rawFlowData.length, 'flow rows');\n  if (rawFlowData.length === 0) {\n    console.log('No flow data parsed');\n    return priceRows;\n  }\n\n  // 2. 데이터 정규화\n  let flowData = normalizeFlowData(rawFlowData);\n  console.log('Normalized', flowData.length, 'flow rows');\n\n  // 3. 주식수 단위 확인 및 변환\n  if (isVolumeUnit(flowData)) {\n    console.log('Volume unit detected, converting to amount');\n    flowData = convertVolumeToAmount(flowData, priceRows);\n  }\n\n  // 4. 가격 데이터와 병합\n  const merged = mergeFlowWithPrice(priceRows, flowData);\n  console.log('Merged data created');\n  return merged;\n}\nexport default {\n  normalizeDate,\n  parseFlowCSV,\n  normalizeFlowData,\n  mergeFlowWithPrice,\n  isVolumeUnit,\n  convertVolumeToAmount,\n  processFlowData\n};","map":{"version":3,"names":["toNum","debugFlowData","normalizeDate","dateStr","str","String","trim","includes","split","parts","length","padStart","parseFlowCSV","csvText","cleanText","charCodeAt","substring","replace","lines","firstLine","headers","map","h","idx","cleaned","console","log","data","i","values","row","forEach","header","_values$idx","push","Object","keys","normalizeFlowData","flowRows","dateValue","normalized","date","금융투자","보험","투신","사모","은행","기타금융","연기금","기타법인","개인","외국인","기타외국인","기관합계","외국인합계","mergeFlowWithPrice","priceRows","flowMap","Map","set","size","Array","from","slice","categories","cumulative","cat","cumForeign","cumInst","cumPerson","priceRow","priceDate","Date","flowData","get","flows","_flows","_cum","foreign","inst","person","isVolumeUnit","firstRow","filter","v","Math","abs","maxValue","max","convertVolumeToAmount","priceMap","close","flowRow","price","converted","numericKeys","key","processFlowData","flowCSV","rawFlowData","merged"],"sources":["C:/Users/kloud/OneDrive/Desktop/Paradise/src/utils/flowDataProcessor.js"],"sourcesContent":["// 수급 데이터 처리 전용 모듈\n// 날짜 매칭 문제를 완전히 해결\n\nimport { toNum } from './dataUtils';\nimport { debugFlowData } from './debugFlowData';\n\n// 날짜를 YYYY-MM-DD 형식으로 정규화\nexport function normalizeDate(dateStr) {\n  if (!dateStr) return '';\n  \n  const str = String(dateStr).trim();\n  \n  // ISO 형식에서 날짜 부분만 추출\n  if (str.includes('T')) {\n    return str.split('T')[0];\n  }\n  \n  // YYYY/MM/DD를 YYYY-MM-DD로 변환\n  if (str.includes('/')) {\n    const parts = str.split('/');\n    if (parts.length === 3) {\n      return `${parts[0]}-${parts[1].padStart(2, '0')}-${parts[2].padStart(2, '0')}`;\n    }\n  }\n  \n  // YYYY-M-D를 YYYY-MM-DD로 변환\n  if (str.includes('-')) {\n    const parts = str.split('-');\n    if (parts.length === 3) {\n      return `${parts[0]}-${parts[1].padStart(2, '0')}-${parts[2].padStart(2, '0')}`;\n    }\n  }\n  \n  return str;\n}\n\n// CSV 텍스트를 파싱하여 수급 데이터 반환\nexport function parseFlowCSV(csvText) {\n  if (!csvText) return [];\n  \n  // BOM 제거 - 매우 철저하게\n  let cleanText = csvText;\n  \n  // UTF-8 BOM (EF BB BF)\n  while (cleanText.charCodeAt(0) === 0xEF && \n         cleanText.charCodeAt(1) === 0xBB && \n         cleanText.charCodeAt(2) === 0xBF) {\n    cleanText = cleanText.substring(3);\n  }\n  \n  // UTF-16 BOM (FE FF or FF FE)\n  while (cleanText.charCodeAt(0) === 0xFEFF || \n         cleanText.charCodeAt(0) === 0xFFFE ||\n         cleanText.charCodeAt(0) === 65279) {\n    cleanText = cleanText.substring(1);\n  }\n  \n  // 다른 형태의 BOM 제거\n  cleanText = cleanText.replace(/^\\uFEFF/, '');\n  cleanText = cleanText.replace(/^\\xEF\\xBB\\xBF/, '');\n  cleanText = cleanText.replace(/^﻿/, '');\n  \n  const lines = cleanText.trim().split(/\\r?\\n/);\n  if (lines.length < 2) return [];\n  \n  // 헤더 파싱\n  const firstLine = lines[0];\n  const headers = firstLine.split(',').map((h, idx) => {\n    // 각 헤더 정리\n    let cleaned = h.trim();\n    \n    // 첫 번째 헤더는 특별히 BOM 제거\n    if (idx === 0) {\n      // 모든 가능한 BOM 제거\n      cleaned = cleaned.replace(/^[\\uFEFF\\xEF\\xBB\\xBF]/, '');\n      cleaned = cleaned.replace(/^﻿/, '');\n      // \"날짜\"만 남기기\n      if (cleaned.includes('날짜')) {\n        cleaned = '날짜';\n      }\n    }\n    \n    return cleaned;\n  });\n  \n  console.log('Clean headers:', headers);\n  console.log('Headers includes 외국인?', headers.includes('외국인'));\n  console.log('Headers includes 기타외국인?', headers.includes('기타외국인'));\n  \n  // 데이터 파싱\n  const data = [];\n  for (let i = 1; i < lines.length; i++) {\n    const values = lines[i].split(',');\n    const row = {};\n    \n    headers.forEach((header, idx) => {\n      row[header] = values[idx]?.trim() || '';\n    });\n    \n    data.push(row);\n  }\n  \n  console.log('Parsed', data.length, 'rows from CSV');\n  if (data.length > 0) {\n    console.log('First row keys:', Object.keys(data[0]));\n    console.log('First row 외국인:', data[0]['외국인']);\n    console.log('First row 기타외국인:', data[0]['기타외국인']);\n    console.log('First row 개인:', data[0]['개인']);\n  }\n  \n  return data;\n}\n\n// 수급 데이터를 정규화\nexport function normalizeFlowData(flowRows) {\n  if (!flowRows || flowRows.length === 0) return [];\n  \n  return flowRows.map((row, idx) => {\n    // 날짜 찾기\n    const dateValue = row['날짜'] || row['date'] || row['Date'] || Object.values(row)[0];\n    \n    const normalized = {\n      date: normalizeDate(dateValue),\n      금융투자: toNum(row['금융투자'] || 0),\n      보험: toNum(row['보험'] || 0),\n      투신: toNum(row['투신'] || 0),\n      사모: toNum(row['사모'] || 0),\n      은행: toNum(row['은행'] || 0),\n      기타금융: toNum(row['기타금융'] || 0),\n      연기금: toNum(row['연기금'] || 0),\n      기타법인: toNum(row['기타법인'] || 0),\n      개인: toNum(row['개인'] || 0),\n      외국인: toNum(row['외국인'] || 0),\n      기타외국인: toNum(row['기타외국인'] || 0),\n      기관합계: toNum(row['기관합계'] || 0)\n    };\n    \n    if (idx === 0) {\n      console.log('First normalized flow row:', {\n        date: normalized.date,\n        외국인: normalized.외국인,\n        기타외국인: normalized.기타외국인,\n        개인: normalized.개인,\n        기관합계: normalized.기관합계\n      });\n    }\n    \n    // 기관합계가 없으면 계산\n    if (!normalized.기관합계) {\n      normalized.기관합계 = \n        normalized.금융투자 + normalized.보험 + normalized.투신 + \n        normalized.사모 + normalized.은행 + normalized.기타금융 + \n        normalized.연기금 + normalized.기타법인;\n    }\n    \n    // 외국인합계 계산\n    normalized.외국인합계 = normalized.외국인 + normalized.기타외국인;\n    \n    return normalized;\n  });\n}\n\n// 가격 데이터와 수급 데이터 병합\nexport function mergeFlowWithPrice(priceRows, flowRows) {\n  if (!priceRows || priceRows.length === 0) return priceRows;\n  if (!flowRows || flowRows.length === 0) return priceRows;\n  \n  // 수급 데이터를 날짜별 Map으로 변환\n  const flowMap = new Map();\n  flowRows.forEach(row => {\n    const date = normalizeDate(row.date);\n    if (date) {\n      flowMap.set(date, row);\n    }\n  });\n  \n  console.log('Flow map created with', flowMap.size, 'entries');\n  console.log('Sample flow dates:', Array.from(flowMap.keys()).slice(0, 5));\n  \n  // 누적 계산용 변수\n  const categories = ['금융투자', '보험', '투신', '사모', '은행', '기타금융', '연기금', '기타법인', '개인', '외국인', '기타외국인', '기관합계', '외국인합계'];\n  const cumulative = {};\n  categories.forEach(cat => { cumulative[cat] = 0; });\n  \n  let cumForeign = 0;\n  let cumInst = 0;\n  let cumPerson = 0;\n  \n  // 가격 데이터에 수급 데이터 병합\n  return priceRows.map((priceRow, idx) => {\n    const priceDate = normalizeDate(priceRow.date || priceRow.Date);\n    const flowData = flowMap.get(priceDate);\n    \n    if (idx < 5) {\n      console.log(`Merging row ${idx}: price date=${priceDate}, flow found=${!!flowData}`);\n      if (flowData) {\n        console.log('Flow data sample:', { \n          금융투자: flowData.금융투자, \n          개인: flowData.개인,\n          외국인: flowData.외국인,\n          기타외국인: flowData.기타외국인,\n          외국인합계: flowData.외국인합계,\n          기관합계: flowData.기관합계\n        });\n      }\n    }\n    \n    // 수급 데이터가 있으면 사용, 없으면 0\n    const flows = flowData || {\n      금융투자: 0, 보험: 0, 투신: 0, 사모: 0, 은행: 0,\n      기타금융: 0, 연기금: 0, 기타법인: 0, 개인: 0,\n      외국인: 0, 기타외국인: 0, 기관합계: 0, 외국인합계: 0\n    };\n    \n    // 누적 계산\n    categories.forEach(cat => {\n      cumulative[cat] += flows[cat] || 0;\n    });\n    \n    cumForeign += flows.외국인합계 || 0;\n    cumInst += flows.기관합계 || 0;\n    cumPerson += flows.개인 || 0;\n    \n    return {\n      ...priceRow,\n      _flows: { ...flows },\n      _cum: { ...cumulative },\n      cumForeign,\n      cumInst,\n      cumPerson,\n      foreign: flows.외국인합계 || 0,\n      inst: flows.기관합계 || 0,\n      person: flows.개인 || 0\n    };\n  });\n}\n\n// 주식수 단위인지 판단\nexport function isVolumeUnit(flowRows) {\n  if (!flowRows || flowRows.length === 0) return false;\n  \n  const firstRow = flowRows[0];\n  const values = Object.values(firstRow)\n    .filter(v => typeof v === 'number' && v !== 0)\n    .map(Math.abs);\n  \n  if (values.length === 0) return false;\n  \n  const maxValue = Math.max(...values);\n  return maxValue < 1000000; // 100만 미만이면 주식수로 판단\n}\n\n// 주식수를 금액으로 변환\nexport function convertVolumeToAmount(flowRows, priceRows) {\n  if (!flowRows || flowRows.length === 0) return flowRows;\n  if (!priceRows || priceRows.length === 0) return flowRows;\n  \n  // 가격 데이터 Map 생성\n  const priceMap = new Map();\n  priceRows.forEach(row => {\n    const date = normalizeDate(row.date || row.Date);\n    if (date && row.close) {\n      priceMap.set(date, toNum(row.close));\n    }\n  });\n  \n  // 수급 데이터 변환\n  return flowRows.map(flowRow => {\n    const date = normalizeDate(flowRow.date);\n    const price = priceMap.get(date);\n    \n    if (!price) return flowRow;\n    \n    const converted = { ...flowRow };\n    const numericKeys = ['금융투자', '보험', '투신', '사모', '은행', '기타금융', '연기금', '기타법인', '개인', '외국인', '기타외국인', '기관합계'];\n    \n    numericKeys.forEach(key => {\n      if (typeof converted[key] === 'number') {\n        converted[key] = converted[key] * price;\n      }\n    });\n    \n    return converted;\n  });\n}\n\n// 통합 처리 함수\nexport function processFlowData(flowCSV, priceRows) {\n  console.log('processFlowData called');\n  \n  if (!flowCSV || !priceRows) {\n    console.log('Missing flow CSV or price rows');\n    return priceRows || [];\n  }\n  \n  // 디버깅: 외국인 데이터 확인\n  debugFlowData(flowCSV);\n  \n  // 1. CSV 파싱\n  const rawFlowData = parseFlowCSV(flowCSV);\n  console.log('Parsed', rawFlowData.length, 'flow rows');\n  \n  if (rawFlowData.length === 0) {\n    console.log('No flow data parsed');\n    return priceRows;\n  }\n  \n  // 2. 데이터 정규화\n  let flowData = normalizeFlowData(rawFlowData);\n  console.log('Normalized', flowData.length, 'flow rows');\n  \n  // 3. 주식수 단위 확인 및 변환\n  if (isVolumeUnit(flowData)) {\n    console.log('Volume unit detected, converting to amount');\n    flowData = convertVolumeToAmount(flowData, priceRows);\n  }\n  \n  // 4. 가격 데이터와 병합\n  const merged = mergeFlowWithPrice(priceRows, flowData);\n  console.log('Merged data created');\n  \n  return merged;\n}\n\nexport default {\n  normalizeDate,\n  parseFlowCSV,\n  normalizeFlowData,\n  mergeFlowWithPrice,\n  isVolumeUnit,\n  convertVolumeToAmount,\n  processFlowData\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}