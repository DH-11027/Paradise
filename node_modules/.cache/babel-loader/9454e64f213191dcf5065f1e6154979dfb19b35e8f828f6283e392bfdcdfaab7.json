{"ast":null,"code":"import{useMemo}from\"react\";import{parseCSV,toNum}from\"../utils/dataUtils\";import{parseInvestorFlowCSV}from\"../utils/investorUtils\";import{computeIndicators,mergeInvestorFlows}from\"../utils/indicatorUtils\";import{sampleOHLCV,sampleFlowBreakdown}from\"../constants/sampleData\";export function useDataProcessing(priceCSV,flowCSV,useSample,anchorIndex){const priceRows=useMemo(()=>{if(!priceCSV)return[];const raw=parseCSV(priceCSV);// Flexible header mapping (supports merged single-CSV that already includes flow columns)\nreturn raw.map(r=>{var _ref,_r$open,_ref2,_r$high,_ref3,_r$low,_ref4,_r$close,_ref5,_r$volume,_ref6,_ref7,_ref8,_r$foreign,_ref9,_ref0,_ref1,_r$institution;return{date:r.date||r.Date||r[\"날짜\"],open:toNum((_ref=(_r$open=r.open)!==null&&_r$open!==void 0?_r$open:r.Open)!==null&&_ref!==void 0?_ref:r[\"시가\"]),high:toNum((_ref2=(_r$high=r.high)!==null&&_r$high!==void 0?_r$high:r.High)!==null&&_ref2!==void 0?_ref2:r[\"고가\"]),low:toNum((_ref3=(_r$low=r.low)!==null&&_r$low!==void 0?_r$low:r.Low)!==null&&_ref3!==void 0?_ref3:r[\"저가\"]),close:toNum((_ref4=(_r$close=r.close)!==null&&_r$close!==void 0?_r$close:r.Close)!==null&&_ref4!==void 0?_ref4:r[\"종가\"]),volume:toNum((_ref5=(_r$volume=r.volume)!==null&&_r$volume!==void 0?_r$volume:r.Volume)!==null&&_ref5!==void 0?_ref5:r[\"거래량\"]),// if merged CSV, keep possible flow fields too (will be ignored here)\nforeign:toNum((_ref6=(_ref7=(_ref8=(_r$foreign=r.foreign)!==null&&_r$foreign!==void 0?_r$foreign:r.Foreign)!==null&&_ref8!==void 0?_ref8:r[\"외국인\"])!==null&&_ref7!==void 0?_ref7:r[\"ForeignNetBuy\"])!==null&&_ref6!==void 0?_ref6:r[\"ForeignNetBuy_MKRW\"]),institution:toNum((_ref9=(_ref0=(_ref1=(_r$institution=r.institution)!==null&&_r$institution!==void 0?_r$institution:r.Institution)!==null&&_ref1!==void 0?_ref1:r[\"기관\"])!==null&&_ref0!==void 0?_ref0:r[\"InstitutionNetBuy\"])!==null&&_ref9!==void 0?_ref9:r[\"InstitutionNetBuy_MKRW\"])};}).filter(r=>r.date&&r.close).sort((a,b)=>new Date(a.date)-new Date(b.date));},[priceCSV]);const flowRows=useMemo(()=>{if(!flowCSV)return[];// 1) Detailed KRX-style CSV\nconst detailed=parseInvestorFlowCSV(flowCSV);if(detailed.length>0)return detailed;// 2) Fallback to simple flow CSV if provided\nconst raw=parseCSV(flowCSV);let parsed=raw.map(r=>{var _ref10,_ref11,_ref12,_r$foreign2,_ref13,_ref14,_ref15,_r$institution2;return{date:r.date||r.Date||r[\"날짜\"],foreign:toNum((_ref10=(_ref11=(_ref12=(_r$foreign2=r.foreign)!==null&&_r$foreign2!==void 0?_r$foreign2:r.Foreign)!==null&&_ref12!==void 0?_ref12:r[\"외국인\"])!==null&&_ref11!==void 0?_ref11:r[\"ForeignNetBuy\"])!==null&&_ref10!==void 0?_ref10:r[\"ForeignNetBuy_MKRW\"]),institution:toNum((_ref13=(_ref14=(_ref15=(_r$institution2=r.institution)!==null&&_r$institution2!==void 0?_r$institution2:r.Institution)!==null&&_ref15!==void 0?_ref15:r[\"기관\"])!==null&&_ref14!==void 0?_ref14:r[\"InstitutionNetBuy\"])!==null&&_ref13!==void 0?_ref13:r[\"InstitutionNetBuy_MKRW\"])};}).filter(r=>r.date).sort((a,b)=>new Date(a.date)-new Date(b.date));// 3) If user provided a single merged CSV (only in left textarea), derive from priceRows\nif(parsed.length===0&&priceRows.length>0){const derived=priceRows.filter(p=>p.date&&(p.foreign!==undefined||p.institution!==undefined)).map(p=>({date:p.date,foreign:toNum(p.foreign),institution:toNum(p.institution)}));if(derived.length>0)parsed=derived;}return parsed;},[flowCSV,priceRows]);const merged=useMemo(()=>mergeInvestorFlows(priceRows,flowRows),[priceRows,flowRows]);const{data:enriched}=useMemo(()=>computeIndicators(merged,anchorIndex),[merged,anchorIndex]);return{priceRows,flowRows,merged,enriched};}","map":{"version":3,"names":["useMemo","parseCSV","toNum","parseInvestorFlowCSV","computeIndicators","mergeInvestorFlows","sampleOHLCV","sampleFlowBreakdown","useDataProcessing","priceCSV","flowCSV","useSample","anchorIndex","priceRows","raw","map","r","_ref","_r$open","_ref2","_r$high","_ref3","_r$low","_ref4","_r$close","_ref5","_r$volume","_ref6","_ref7","_ref8","_r$foreign","_ref9","_ref0","_ref1","_r$institution","date","Date","open","Open","high","High","low","Low","close","Close","volume","Volume","foreign","Foreign","institution","Institution","filter","sort","a","b","flowRows","detailed","length","parsed","_ref10","_ref11","_ref12","_r$foreign2","_ref13","_ref14","_ref15","_r$institution2","derived","p","undefined","merged","data","enriched"],"sources":["C:/Users/kloud/OneDrive/Desktop/Paradise/src/hooks/useDataProcessing.js"],"sourcesContent":["import { useMemo } from \"react\";\nimport { parseCSV, toNum } from \"../utils/dataUtils\";\nimport { parseInvestorFlowCSV } from \"../utils/investorUtils\";\nimport { computeIndicators, mergeInvestorFlows } from \"../utils/indicatorUtils\";\nimport { sampleOHLCV, sampleFlowBreakdown } from \"../constants/sampleData\";\n\nexport function useDataProcessing(priceCSV, flowCSV, useSample, anchorIndex) {\n  const priceRows = useMemo(() => {\n    if (!priceCSV) return [];\n    const raw = parseCSV(priceCSV);\n    // Flexible header mapping (supports merged single-CSV that already includes flow columns)\n    return raw\n      .map((r) => ({\n        date: r.date || r.Date || r[\"날짜\"],\n        open: toNum(r.open ?? r.Open ?? r[\"시가\"]),\n        high: toNum(r.high ?? r.High ?? r[\"고가\"]),\n        low: toNum(r.low ?? r.Low ?? r[\"저가\"]),\n        close: toNum(r.close ?? r.Close ?? r[\"종가\"]),\n        volume: toNum(r.volume ?? r.Volume ?? r[\"거래량\"]),\n        // if merged CSV, keep possible flow fields too (will be ignored here)\n        foreign: toNum(\n          r.foreign ?? r.Foreign ?? r[\"외국인\"] ?? r[\"ForeignNetBuy\"] ?? r[\"ForeignNetBuy_MKRW\"]\n        ),\n        institution: toNum(\n          r.institution ?? r.Institution ?? r[\"기관\"] ?? r[\"InstitutionNetBuy\"] ?? r[\"InstitutionNetBuy_MKRW\"]\n        ),\n      }))\n      .filter((r) => r.date && r.close)\n      .sort((a, b) => new Date(a.date) - new Date(b.date));\n  }, [priceCSV]);\n\n  const flowRows = useMemo(() => {\n    if (!flowCSV) return [];\n\n    // 1) Detailed KRX-style CSV\n    const detailed = parseInvestorFlowCSV(flowCSV);\n    if (detailed.length > 0) return detailed;\n\n    // 2) Fallback to simple flow CSV if provided\n    const raw = parseCSV(flowCSV);\n    let parsed = raw\n      .map((r) => ({\n        date: r.date || r.Date || r[\"날짜\"],\n        foreign: toNum(\n          r.foreign ?? r.Foreign ?? r[\"외국인\"] ?? r[\"ForeignNetBuy\"] ?? r[\"ForeignNetBuy_MKRW\"]\n        ),\n        institution: toNum(\n          r.institution ?? r.Institution ?? r[\"기관\"] ?? r[\"InstitutionNetBuy\"] ?? r[\"InstitutionNetBuy_MKRW\"]\n        ),\n      }))\n      .filter((r) => r.date)\n      .sort((a, b) => new Date(a.date) - new Date(b.date));\n\n    // 3) If user provided a single merged CSV (only in left textarea), derive from priceRows\n    if (parsed.length === 0 && priceRows.length > 0) {\n      const derived = priceRows\n        .filter((p) => p.date && (p.foreign !== undefined || p.institution !== undefined))\n        .map((p) => ({ date: p.date, foreign: toNum(p.foreign), institution: toNum(p.institution) }));\n      if (derived.length > 0) parsed = derived;\n    }\n\n    return parsed;\n  }, [flowCSV, priceRows]);\n\n  const merged = useMemo(() => mergeInvestorFlows(priceRows, flowRows), [priceRows, flowRows]);\n  const { data: enriched } = useMemo(() => computeIndicators(merged, anchorIndex), [merged, anchorIndex]);\n\n  return { priceRows, flowRows, merged, enriched };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}