{"ast":null,"code":"// 강력한 CSV 파서 - BOM과 한글 처리 최적화\n\nexport function robustParseCSV(text) {\n  if (!text) return [];\n\n  // 1. 모든 종류의 BOM 제거\n  let cleanText = text;\n\n  // UTF-8 BOM\n  if (cleanText.charCodeAt(0) === 0xFEFF) {\n    cleanText = cleanText.substring(1);\n  }\n\n  // 다른 형태의 BOM들\n  cleanText = cleanText.replace(/^\\uFEFF/, '');\n  cleanText = cleanText.replace(/^\\xEF\\xBB\\xBF/, '');\n  cleanText = cleanText.replace(/^﻿/, '');\n\n  // 앞뒤 공백 제거\n  cleanText = cleanText.trim();\n\n  // 2. 줄 단위로 분리\n  const lines = cleanText.split(/\\r?\\n/).filter(line => line.trim().length > 0);\n  if (lines.length < 2) {\n    console.warn('CSV has less than 2 lines');\n    return [];\n  }\n\n  // 3. 구분자 감지 (콤마 또는 탭)\n  const firstLine = lines[0];\n  let separator = ',';\n  if (firstLine.includes('\\t')) {\n    separator = '\\t';\n  }\n\n  // 4. 헤더 파싱\n  const headers = parseLine(firstLine, separator).map(h => {\n    // 헤더에서도 BOM 제거\n    let clean = h.trim();\n    clean = clean.replace(/^\\uFEFF/, '');\n    clean = clean.replace(/^\\xEF\\xBB\\xBF/, '');\n    clean = clean.replace(/^﻿/, '');\n    return clean;\n  });\n  console.log('Parsed headers:', headers);\n\n  // 5. 데이터 행 파싱\n  const data = [];\n  for (let i = 1; i < lines.length; i++) {\n    const values = parseLine(lines[i], separator);\n    const row = {};\n    headers.forEach((header, index) => {\n      row[header] = values[index] || '';\n    });\n    data.push(row);\n  }\n  return data;\n}\n\n// CSV 라인 파싱 (따옴표 처리 포함)\nfunction parseLine(line, separator) {\n  const result = [];\n  let current = '';\n  let inQuotes = false;\n  for (let i = 0; i < line.length; i++) {\n    const char = line[i];\n    const nextChar = line[i + 1];\n    if (char === '\"') {\n      if (inQuotes && nextChar === '\"') {\n        // 이중 따옴표는 하나의 따옴표로\n        current += '\"';\n        i++; // 다음 따옴표 건너뛰기\n      } else {\n        // 따옴표 모드 토글\n        inQuotes = !inQuotes;\n      }\n    } else if (char === separator && !inQuotes) {\n      // 구분자를 만났고 따옴표 안이 아니면 필드 구분\n      result.push(current.trim());\n      current = '';\n    } else {\n      current += char;\n    }\n  }\n\n  // 마지막 필드 추가\n  result.push(current.trim());\n  return result;\n}\n\n// 투자자 수급 데이터 전용 파서\nexport function parseInvestorFlowData(text) {\n  const rows = robustParseCSV(text);\n  if (rows.length === 0) {\n    console.warn('No rows parsed from investor flow data');\n    return [];\n  }\n\n  // 헤더 확인\n  const firstRow = rows[0];\n  const headers = Object.keys(firstRow);\n  console.log('Investor flow headers:', headers);\n\n  // 날짜 필드 찾기\n  const dateField = headers.find(h => h === '날짜' || h === 'date' || h === 'Date' || h.includes('날짜'));\n  if (!dateField) {\n    console.warn('No date field found, using first column');\n  }\n\n  // 데이터 정규화\n  return rows.map(row => {\n    const normalized = {};\n\n    // 날짜\n    normalized.date = row[dateField] || row[headers[0]] || '';\n\n    // 투자자별 수급 (한글 키 그대로 사용)\n    const investorKeys = ['금융투자', '보험', '투신', '사모', '은행', '기타금융', '연기금', '기타법인', '개인', '외국인', '기타외국인', '기관합계'];\n    investorKeys.forEach(key => {\n      const value = row[key];\n      normalized[key] = parseNumber(value);\n    });\n\n    // 기관합계가 없으면 계산\n    if (!normalized['기관합계'] || normalized['기관합계'] === 0) {\n      const institutionKeys = ['금융투자', '보험', '투신', '사모', '은행', '기타금융', '연기금', '기타법인'];\n      normalized['기관합계'] = institutionKeys.reduce((sum, key) => sum + (normalized[key] || 0), 0);\n    }\n\n    // 외국인합계 계산\n    normalized['외국인합계'] = (normalized['외국인'] || 0) + (normalized['기타외국인'] || 0);\n    return normalized;\n  }).filter(row => row.date); // 날짜가 있는 행만 반환\n}\n\n// 숫자 파싱 헬퍼\nfunction parseNumber(value) {\n  if (typeof value === 'number') return value;\n  if (!value) return 0;\n  const str = String(value).trim();\n  if (str === '' || str === '-') return 0;\n\n  // 콤마 제거\n  const cleaned = str.replace(/,/g, '');\n\n  // 숫자로 변환\n  const num = Number(cleaned);\n  return isFinite(num) ? num : 0;\n}\nexport default {\n  robustParseCSV,\n  parseInvestorFlowData\n};","map":{"version":3,"names":["robustParseCSV","text","cleanText","charCodeAt","substring","replace","trim","lines","split","filter","line","length","console","warn","firstLine","separator","includes","headers","parseLine","map","h","clean","log","data","i","values","row","forEach","header","index","push","result","current","inQuotes","char","nextChar","parseInvestorFlowData","rows","firstRow","Object","keys","dateField","find","normalized","date","investorKeys","key","value","parseNumber","institutionKeys","reduce","sum","str","String","cleaned","num","Number","isFinite"],"sources":["C:/Users/kloud/OneDrive/Desktop/Paradise/src/utils/robustCSVParser.js"],"sourcesContent":["// 강력한 CSV 파서 - BOM과 한글 처리 최적화\n\nexport function robustParseCSV(text) {\n  if (!text) return [];\n  \n  // 1. 모든 종류의 BOM 제거\n  let cleanText = text;\n  \n  // UTF-8 BOM\n  if (cleanText.charCodeAt(0) === 0xFEFF) {\n    cleanText = cleanText.substring(1);\n  }\n  \n  // 다른 형태의 BOM들\n  cleanText = cleanText.replace(/^\\uFEFF/, '');\n  cleanText = cleanText.replace(/^\\xEF\\xBB\\xBF/, '');\n  cleanText = cleanText.replace(/^﻿/, '');\n  \n  // 앞뒤 공백 제거\n  cleanText = cleanText.trim();\n  \n  // 2. 줄 단위로 분리\n  const lines = cleanText.split(/\\r?\\n/).filter(line => line.trim().length > 0);\n  \n  if (lines.length < 2) {\n    console.warn('CSV has less than 2 lines');\n    return [];\n  }\n  \n  // 3. 구분자 감지 (콤마 또는 탭)\n  const firstLine = lines[0];\n  let separator = ',';\n  \n  if (firstLine.includes('\\t')) {\n    separator = '\\t';\n  }\n  \n  // 4. 헤더 파싱\n  const headers = parseLine(firstLine, separator).map(h => {\n    // 헤더에서도 BOM 제거\n    let clean = h.trim();\n    clean = clean.replace(/^\\uFEFF/, '');\n    clean = clean.replace(/^\\xEF\\xBB\\xBF/, '');\n    clean = clean.replace(/^﻿/, '');\n    return clean;\n  });\n  \n  console.log('Parsed headers:', headers);\n  \n  // 5. 데이터 행 파싱\n  const data = [];\n  for (let i = 1; i < lines.length; i++) {\n    const values = parseLine(lines[i], separator);\n    const row = {};\n    \n    headers.forEach((header, index) => {\n      row[header] = values[index] || '';\n    });\n    \n    data.push(row);\n  }\n  \n  return data;\n}\n\n// CSV 라인 파싱 (따옴표 처리 포함)\nfunction parseLine(line, separator) {\n  const result = [];\n  let current = '';\n  let inQuotes = false;\n  \n  for (let i = 0; i < line.length; i++) {\n    const char = line[i];\n    const nextChar = line[i + 1];\n    \n    if (char === '\"') {\n      if (inQuotes && nextChar === '\"') {\n        // 이중 따옴표는 하나의 따옴표로\n        current += '\"';\n        i++; // 다음 따옴표 건너뛰기\n      } else {\n        // 따옴표 모드 토글\n        inQuotes = !inQuotes;\n      }\n    } else if (char === separator && !inQuotes) {\n      // 구분자를 만났고 따옴표 안이 아니면 필드 구분\n      result.push(current.trim());\n      current = '';\n    } else {\n      current += char;\n    }\n  }\n  \n  // 마지막 필드 추가\n  result.push(current.trim());\n  \n  return result;\n}\n\n// 투자자 수급 데이터 전용 파서\nexport function parseInvestorFlowData(text) {\n  const rows = robustParseCSV(text);\n  \n  if (rows.length === 0) {\n    console.warn('No rows parsed from investor flow data');\n    return [];\n  }\n  \n  // 헤더 확인\n  const firstRow = rows[0];\n  const headers = Object.keys(firstRow);\n  console.log('Investor flow headers:', headers);\n  \n  // 날짜 필드 찾기\n  const dateField = headers.find(h => \n    h === '날짜' || \n    h === 'date' || \n    h === 'Date' || \n    h.includes('날짜')\n  );\n  \n  if (!dateField) {\n    console.warn('No date field found, using first column');\n  }\n  \n  // 데이터 정규화\n  return rows.map(row => {\n    const normalized = {};\n    \n    // 날짜\n    normalized.date = row[dateField] || row[headers[0]] || '';\n    \n    // 투자자별 수급 (한글 키 그대로 사용)\n    const investorKeys = [\n      '금융투자', '보험', '투신', '사모', '은행', \n      '기타금융', '연기금', '기타법인', '개인', \n      '외국인', '기타외국인', '기관합계'\n    ];\n    \n    investorKeys.forEach(key => {\n      const value = row[key];\n      normalized[key] = parseNumber(value);\n    });\n    \n    // 기관합계가 없으면 계산\n    if (!normalized['기관합계'] || normalized['기관합계'] === 0) {\n      const institutionKeys = [\n        '금융투자', '보험', '투신', '사모', '은행', \n        '기타금융', '연기금', '기타법인'\n      ];\n      normalized['기관합계'] = institutionKeys.reduce((sum, key) => \n        sum + (normalized[key] || 0), 0\n      );\n    }\n    \n    // 외국인합계 계산\n    normalized['외국인합계'] = (normalized['외국인'] || 0) + (normalized['기타외국인'] || 0);\n    \n    return normalized;\n  }).filter(row => row.date); // 날짜가 있는 행만 반환\n}\n\n// 숫자 파싱 헬퍼\nfunction parseNumber(value) {\n  if (typeof value === 'number') return value;\n  if (!value) return 0;\n  \n  const str = String(value).trim();\n  if (str === '' || str === '-') return 0;\n  \n  // 콤마 제거\n  const cleaned = str.replace(/,/g, '');\n  \n  // 숫자로 변환\n  const num = Number(cleaned);\n  return isFinite(num) ? num : 0;\n}\n\nexport default {\n  robustParseCSV,\n  parseInvestorFlowData\n};"],"mappings":"AAAA;;AAEA,OAAO,SAASA,cAAcA,CAACC,IAAI,EAAE;EACnC,IAAI,CAACA,IAAI,EAAE,OAAO,EAAE;;EAEpB;EACA,IAAIC,SAAS,GAAGD,IAAI;;EAEpB;EACA,IAAIC,SAAS,CAACC,UAAU,CAAC,CAAC,CAAC,KAAK,MAAM,EAAE;IACtCD,SAAS,GAAGA,SAAS,CAACE,SAAS,CAAC,CAAC,CAAC;EACpC;;EAEA;EACAF,SAAS,GAAGA,SAAS,CAACG,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC;EAC5CH,SAAS,GAAGA,SAAS,CAACG,OAAO,CAAC,eAAe,EAAE,EAAE,CAAC;EAClDH,SAAS,GAAGA,SAAS,CAACG,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;;EAEvC;EACAH,SAAS,GAAGA,SAAS,CAACI,IAAI,CAAC,CAAC;;EAE5B;EACA,MAAMC,KAAK,GAAGL,SAAS,CAACM,KAAK,CAAC,OAAO,CAAC,CAACC,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACJ,IAAI,CAAC,CAAC,CAACK,MAAM,GAAG,CAAC,CAAC;EAE7E,IAAIJ,KAAK,CAACI,MAAM,GAAG,CAAC,EAAE;IACpBC,OAAO,CAACC,IAAI,CAAC,2BAA2B,CAAC;IACzC,OAAO,EAAE;EACX;;EAEA;EACA,MAAMC,SAAS,GAAGP,KAAK,CAAC,CAAC,CAAC;EAC1B,IAAIQ,SAAS,GAAG,GAAG;EAEnB,IAAID,SAAS,CAACE,QAAQ,CAAC,IAAI,CAAC,EAAE;IAC5BD,SAAS,GAAG,IAAI;EAClB;;EAEA;EACA,MAAME,OAAO,GAAGC,SAAS,CAACJ,SAAS,EAAEC,SAAS,CAAC,CAACI,GAAG,CAACC,CAAC,IAAI;IACvD;IACA,IAAIC,KAAK,GAAGD,CAAC,CAACd,IAAI,CAAC,CAAC;IACpBe,KAAK,GAAGA,KAAK,CAAChB,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC;IACpCgB,KAAK,GAAGA,KAAK,CAAChB,OAAO,CAAC,eAAe,EAAE,EAAE,CAAC;IAC1CgB,KAAK,GAAGA,KAAK,CAAChB,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;IAC/B,OAAOgB,KAAK;EACd,CAAC,CAAC;EAEFT,OAAO,CAACU,GAAG,CAAC,iBAAiB,EAAEL,OAAO,CAAC;;EAEvC;EACA,MAAMM,IAAI,GAAG,EAAE;EACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjB,KAAK,CAACI,MAAM,EAAEa,CAAC,EAAE,EAAE;IACrC,MAAMC,MAAM,GAAGP,SAAS,CAACX,KAAK,CAACiB,CAAC,CAAC,EAAET,SAAS,CAAC;IAC7C,MAAMW,GAAG,GAAG,CAAC,CAAC;IAEdT,OAAO,CAACU,OAAO,CAAC,CAACC,MAAM,EAAEC,KAAK,KAAK;MACjCH,GAAG,CAACE,MAAM,CAAC,GAAGH,MAAM,CAACI,KAAK,CAAC,IAAI,EAAE;IACnC,CAAC,CAAC;IAEFN,IAAI,CAACO,IAAI,CAACJ,GAAG,CAAC;EAChB;EAEA,OAAOH,IAAI;AACb;;AAEA;AACA,SAASL,SAASA,CAACR,IAAI,EAAEK,SAAS,EAAE;EAClC,MAAMgB,MAAM,GAAG,EAAE;EACjB,IAAIC,OAAO,GAAG,EAAE;EAChB,IAAIC,QAAQ,GAAG,KAAK;EAEpB,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,IAAI,CAACC,MAAM,EAAEa,CAAC,EAAE,EAAE;IACpC,MAAMU,IAAI,GAAGxB,IAAI,CAACc,CAAC,CAAC;IACpB,MAAMW,QAAQ,GAAGzB,IAAI,CAACc,CAAC,GAAG,CAAC,CAAC;IAE5B,IAAIU,IAAI,KAAK,GAAG,EAAE;MAChB,IAAID,QAAQ,IAAIE,QAAQ,KAAK,GAAG,EAAE;QAChC;QACAH,OAAO,IAAI,GAAG;QACdR,CAAC,EAAE,CAAC,CAAC;MACP,CAAC,MAAM;QACL;QACAS,QAAQ,GAAG,CAACA,QAAQ;MACtB;IACF,CAAC,MAAM,IAAIC,IAAI,KAAKnB,SAAS,IAAI,CAACkB,QAAQ,EAAE;MAC1C;MACAF,MAAM,CAACD,IAAI,CAACE,OAAO,CAAC1B,IAAI,CAAC,CAAC,CAAC;MAC3B0B,OAAO,GAAG,EAAE;IACd,CAAC,MAAM;MACLA,OAAO,IAAIE,IAAI;IACjB;EACF;;EAEA;EACAH,MAAM,CAACD,IAAI,CAACE,OAAO,CAAC1B,IAAI,CAAC,CAAC,CAAC;EAE3B,OAAOyB,MAAM;AACf;;AAEA;AACA,OAAO,SAASK,qBAAqBA,CAACnC,IAAI,EAAE;EAC1C,MAAMoC,IAAI,GAAGrC,cAAc,CAACC,IAAI,CAAC;EAEjC,IAAIoC,IAAI,CAAC1B,MAAM,KAAK,CAAC,EAAE;IACrBC,OAAO,CAACC,IAAI,CAAC,wCAAwC,CAAC;IACtD,OAAO,EAAE;EACX;;EAEA;EACA,MAAMyB,QAAQ,GAAGD,IAAI,CAAC,CAAC,CAAC;EACxB,MAAMpB,OAAO,GAAGsB,MAAM,CAACC,IAAI,CAACF,QAAQ,CAAC;EACrC1B,OAAO,CAACU,GAAG,CAAC,wBAAwB,EAAEL,OAAO,CAAC;;EAE9C;EACA,MAAMwB,SAAS,GAAGxB,OAAO,CAACyB,IAAI,CAACtB,CAAC,IAC9BA,CAAC,KAAK,IAAI,IACVA,CAAC,KAAK,MAAM,IACZA,CAAC,KAAK,MAAM,IACZA,CAAC,CAACJ,QAAQ,CAAC,IAAI,CACjB,CAAC;EAED,IAAI,CAACyB,SAAS,EAAE;IACd7B,OAAO,CAACC,IAAI,CAAC,yCAAyC,CAAC;EACzD;;EAEA;EACA,OAAOwB,IAAI,CAAClB,GAAG,CAACO,GAAG,IAAI;IACrB,MAAMiB,UAAU,GAAG,CAAC,CAAC;;IAErB;IACAA,UAAU,CAACC,IAAI,GAAGlB,GAAG,CAACe,SAAS,CAAC,IAAIf,GAAG,CAACT,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;;IAEzD;IACA,MAAM4B,YAAY,GAAG,CACnB,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9B,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAC3B,KAAK,EAAE,OAAO,EAAE,MAAM,CACvB;IAEDA,YAAY,CAAClB,OAAO,CAACmB,GAAG,IAAI;MAC1B,MAAMC,KAAK,GAAGrB,GAAG,CAACoB,GAAG,CAAC;MACtBH,UAAU,CAACG,GAAG,CAAC,GAAGE,WAAW,CAACD,KAAK,CAAC;IACtC,CAAC,CAAC;;IAEF;IACA,IAAI,CAACJ,UAAU,CAAC,MAAM,CAAC,IAAIA,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE;MACnD,MAAMM,eAAe,GAAG,CACtB,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAC9B,MAAM,EAAE,KAAK,EAAE,MAAM,CACtB;MACDN,UAAU,CAAC,MAAM,CAAC,GAAGM,eAAe,CAACC,MAAM,CAAC,CAACC,GAAG,EAAEL,GAAG,KACnDK,GAAG,IAAIR,UAAU,CAACG,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,CAChC,CAAC;IACH;;IAEA;IACAH,UAAU,CAAC,OAAO,CAAC,GAAG,CAACA,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,KAAKA,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IAE3E,OAAOA,UAAU;EACnB,CAAC,CAAC,CAAClC,MAAM,CAACiB,GAAG,IAAIA,GAAG,CAACkB,IAAI,CAAC,CAAC,CAAC;AAC9B;;AAEA;AACA,SAASI,WAAWA,CAACD,KAAK,EAAE;EAC1B,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE,OAAOA,KAAK;EAC3C,IAAI,CAACA,KAAK,EAAE,OAAO,CAAC;EAEpB,MAAMK,GAAG,GAAGC,MAAM,CAACN,KAAK,CAAC,CAACzC,IAAI,CAAC,CAAC;EAChC,IAAI8C,GAAG,KAAK,EAAE,IAAIA,GAAG,KAAK,GAAG,EAAE,OAAO,CAAC;;EAEvC;EACA,MAAME,OAAO,GAAGF,GAAG,CAAC/C,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;;EAErC;EACA,MAAMkD,GAAG,GAAGC,MAAM,CAACF,OAAO,CAAC;EAC3B,OAAOG,QAAQ,CAACF,GAAG,CAAC,GAAGA,GAAG,GAAG,CAAC;AAChC;AAEA,eAAe;EACbvD,cAAc;EACdoC;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}