{"ast":null,"code":"// =============================\n// Data parsing and formatting utilities\n// =============================\n\nexport function parseCSV(text) {\n  // Minimal CSV parser (comma or tab). Expects header row.\n  // Remove all possible BOM variants\n  let cleanText = text;\n\n  // Remove various BOM encodings\n  cleanText = cleanText.replace(/^\\uFEFF/, ''); // UTF-16 BOM\n  cleanText = cleanText.replace(/^\\xEF\\xBB\\xBF/, ''); // UTF-8 BOM as hex\n  cleanText = cleanText.replace(/^﻿/, ''); // UTF-8 BOM as character\n\n  // Remove BOM if it appears as actual character codes\n  if (cleanText.charCodeAt(0) === 0xFEFF || cleanText.charCodeAt(0) === 65279) {\n    cleanText = cleanText.substring(1);\n  }\n  cleanText = cleanText.trim();\n  console.log('CSV parsing - first 100 chars:', cleanText.substring(0, 100));\n  const lines = cleanText.split(/\\r?\\n/).filter(Boolean);\n  if (lines.length < 2) {\n    console.log('CSV parsing failed: not enough lines', lines.length);\n    return [];\n  }\n  const sep = lines[0].includes(\"\\t\") ? \"\\t\" : \",\";\n  const headers = lines[0].split(sep).map(h => {\n    // Clean each header\n    let cleaned = h.trim();\n    cleaned = cleaned.replace(/^[\\uFEFF\\xEF\\xBB\\xBF]/, '');\n    cleaned = cleaned.replace(/^\"(.*)\"$/, '$1'); // Remove quotes if present\n    return cleaned;\n  });\n  console.log('CSV headers detected:', headers);\n  const data = lines.slice(1).map((line, idx) => {\n    const cols = line.split(sep);\n    const row = {};\n    headers.forEach((h, i) => {\n      var _cols$i$trim, _cols$i, _cols$i$trim2;\n      let value = (_cols$i$trim = (_cols$i = cols[i]) === null || _cols$i === void 0 ? void 0 : (_cols$i$trim2 = _cols$i.trim) === null || _cols$i$trim2 === void 0 ? void 0 : _cols$i$trim2.call(_cols$i)) !== null && _cols$i$trim !== void 0 ? _cols$i$trim : \"\";\n      value = value.replace(/^\"(.*)\"$/, '$1'); // Remove quotes if present\n      row[h] = value;\n    });\n    if (idx < 2) console.log(`CSV row ${idx}:`, row);\n    return row;\n  });\n  console.log(`CSV parsed ${data.length} rows`);\n  return data;\n}\nexport function toNum(v) {\n  if (typeof v === \"number\") return v;\n  if (v === null || v === undefined) return 0;\n  const s = String(v).trim();\n  if (s === \"\" || s === \"-\") return 0;\n  // Remove commas and KR units; support scientific notation (e.g., -1.1E+09)\n  const clean = s.replace(/,/g, \"\").replace(/원|주|%/g, \"\");\n  const n = Number(clean);\n  return Number.isFinite(n) ? n : 0;\n}\nexport function fmtDate(d) {\n  if (!d) return \"\";\n\n  // 문자열인 경우 다양한 형식 처리\n  if (typeof d === 'string') {\n    // T가 포함된 ISO 형식이면 날짜 부분만 추출\n    if (d.includes('T')) {\n      return d.split('T')[0];\n    }\n\n    // YYYY-MM-DD 또는 YYYY/MM/DD 형식 처리\n    const cleaned = d.trim().replace(/\\//g, '-');\n\n    // YYYY-M-D 형식을 YYYY-MM-DD로 변환\n    const parts = cleaned.split('-');\n    if (parts.length === 3) {\n      const year = parts[0];\n      const month = parts[1].padStart(2, '0');\n      const day = parts[2].padStart(2, '0');\n      return `${year}-${month}-${day}`;\n    }\n  }\n\n  // Date 객체로 파싱 시도\n  try {\n    const t = new Date(d);\n    if (!Number.isNaN(t.getTime())) {\n      return t.toISOString().slice(0, 10);\n    }\n  } catch (e) {\n    // 파싱 실패\n  }\n  return String(d); // keep original if invalid\n}","map":{"version":3,"names":["parseCSV","text","cleanText","replace","charCodeAt","substring","trim","console","log","lines","split","filter","Boolean","length","sep","includes","headers","map","h","cleaned","data","slice","line","idx","cols","row","forEach","i","_cols$i$trim","_cols$i","_cols$i$trim2","value","call","toNum","v","undefined","s","String","clean","n","Number","isFinite","fmtDate","d","parts","year","month","padStart","day","t","Date","isNaN","getTime","toISOString","e"],"sources":["C:/Users/kloud/OneDrive/Desktop/Paradise/src/utils/dataUtils.js"],"sourcesContent":["// =============================\n// Data parsing and formatting utilities\n// =============================\n\nexport function parseCSV(text) {\n  // Minimal CSV parser (comma or tab). Expects header row.\n  // Remove all possible BOM variants\n  let cleanText = text;\n  \n  // Remove various BOM encodings\n  cleanText = cleanText.replace(/^\\uFEFF/, ''); // UTF-16 BOM\n  cleanText = cleanText.replace(/^\\xEF\\xBB\\xBF/, ''); // UTF-8 BOM as hex\n  cleanText = cleanText.replace(/^﻿/, ''); // UTF-8 BOM as character\n  \n  // Remove BOM if it appears as actual character codes\n  if (cleanText.charCodeAt(0) === 0xFEFF || cleanText.charCodeAt(0) === 65279) {\n    cleanText = cleanText.substring(1);\n  }\n  \n  cleanText = cleanText.trim();\n  \n  console.log('CSV parsing - first 100 chars:', cleanText.substring(0, 100));\n  \n  const lines = cleanText.split(/\\r?\\n/).filter(Boolean);\n  if (lines.length < 2) {\n    console.log('CSV parsing failed: not enough lines', lines.length);\n    return [];\n  }\n  \n  const sep = lines[0].includes(\"\\t\") ? \"\\t\" : \",\";\n  const headers = lines[0].split(sep).map((h) => {\n    // Clean each header\n    let cleaned = h.trim();\n    cleaned = cleaned.replace(/^[\\uFEFF\\xEF\\xBB\\xBF]/, '');\n    cleaned = cleaned.replace(/^\"(.*)\"$/, '$1'); // Remove quotes if present\n    return cleaned;\n  });\n  \n  console.log('CSV headers detected:', headers);\n  \n  const data = lines.slice(1).map((line, idx) => {\n    const cols = line.split(sep);\n    const row = {};\n    headers.forEach((h, i) => {\n      let value = cols[i]?.trim?.() ?? \"\";\n      value = value.replace(/^\"(.*)\"$/, '$1'); // Remove quotes if present\n      row[h] = value;\n    });\n    if (idx < 2) console.log(`CSV row ${idx}:`, row);\n    return row;\n  });\n  \n  console.log(`CSV parsed ${data.length} rows`);\n  return data;\n}\n\nexport function toNum(v) {\n  if (typeof v === \"number\") return v;\n  if (v === null || v === undefined) return 0;\n  const s = String(v).trim();\n  if (s === \"\" || s === \"-\") return 0;\n  // Remove commas and KR units; support scientific notation (e.g., -1.1E+09)\n  const clean = s.replace(/,/g, \"\").replace(/원|주|%/g, \"\");\n  const n = Number(clean);\n  return Number.isFinite(n) ? n : 0;\n}\n\nexport function fmtDate(d) {\n  if (!d) return \"\";\n  \n  // 문자열인 경우 다양한 형식 처리\n  if (typeof d === 'string') {\n    // T가 포함된 ISO 형식이면 날짜 부분만 추출\n    if (d.includes('T')) {\n      return d.split('T')[0];\n    }\n    \n    // YYYY-MM-DD 또는 YYYY/MM/DD 형식 처리\n    const cleaned = d.trim().replace(/\\//g, '-');\n    \n    // YYYY-M-D 형식을 YYYY-MM-DD로 변환\n    const parts = cleaned.split('-');\n    if (parts.length === 3) {\n      const year = parts[0];\n      const month = parts[1].padStart(2, '0');\n      const day = parts[2].padStart(2, '0');\n      return `${year}-${month}-${day}`;\n    }\n  }\n  \n  // Date 객체로 파싱 시도\n  try {\n    const t = new Date(d);\n    if (!Number.isNaN(t.getTime())) {\n      return t.toISOString().slice(0, 10);\n    }\n  } catch (e) {\n    // 파싱 실패\n  }\n  \n  return String(d); // keep original if invalid\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}